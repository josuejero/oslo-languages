
================================================================================
File: ./repro.v5.test.ts
================================================================================

// repro.v5.test.ts
describe('Remark ESM V5 Transformation', () => {
  it('should convert markdown to HTML correctly', async () => {
    try {
      console.debug('[V5] Starting dynamic import for the "remark" module.');
      const remarkModule = await import('remark');
      // Retrieve the named export "remark"
      const remarkFn = remarkModule.remark;
      if (!remarkFn) {
        throw new Error('[V5] The "remark" export was not found in the remark module.');
      }
      console.debug('[V5] "remark" function loaded:', remarkFn);

      console.debug('[V5] Starting dynamic import for "remark-html".');
      const remarkHtmlModule = await import('remark-html');
      // Get its default export (if available)
      const remarkHtmlFn = remarkHtmlModule.default || remarkHtmlModule;
      if (!remarkHtmlFn) {
        throw new Error('[V5] The default export from remark-html is missing.');
      }
      console.debug('[V5] "remark-html" loaded:', remarkHtmlFn);

      const inputMd = '# V5 Markdown Check';
      console.debug('[V5] Processing markdown input:', inputMd);

      const result = await remarkFn().use(remarkHtmlFn).process(inputMd);
      const htmlOutput = result.toString();
      console.debug('[V5] Obtained HTML output:', htmlOutput);

      expect(htmlOutput).toContain('<h1>V5 Markdown Check</h1>');
    } catch (err) {
      console.error('[V5] Error during markdown transformation:', err);
      throw err;
    }
  });
});

================================================================================
File: ./repro.v4.test.ts
================================================================================

// repro.v4.test.ts
describe('Remark ESM V4 Repro', () => {
  it('transforms markdown input into correct HTML output', async () => {
    try {
      console.debug('[V4] Initiating dynamic import for "remark" module.');
      const { remark: rm } = await import('remark');
      if (!rm) {
        throw new Error('[V4] "remark" export is not available.');
      }
      console.debug('[V4] Successfully imported "remark":', rm);

      console.debug('[V4] Initiating dynamic import for "remark-html" module.');
      const htmlMod = await import('remark-html');
      const htmlTransformer = (htmlMod as { default: any }).default;
      if (!htmlTransformer) {
        throw new Error('[V4] "remark-html" default export is missing.');
      }
      console.debug('[V4] Successfully imported "remark-html":', htmlTransformer);

      console.debug('[V4] Converting markdown to HTML...');
      const markdownInput = '# V4 Markdown Test';
      const processed = await rm().use(htmlTransformer).process(markdownInput);
      const htmlResult = processed.toString();
      console.debug('[V4] HTML Output:', htmlResult);

      expect(htmlResult).toContain('<h1>V4 Markdown Test</h1>');
    } catch (error) {
      console.error('[V4] Error during transformation:', error);
      throw error;
    }
  });
});

================================================================================
File: ./node_modules/tsconfig-paths/src/__tests__/match-path-sync.test.ts
================================================================================

import { createMatchPath } from "../match-path-sync";
import * as Tests from "./data/match-path-data";

describe("match-path-sync", () => {
  Tests.tests.forEach((t) =>
    it(t.name, () => {
      const matchPath = createMatchPath(
        t.absoluteBaseUrl,
        t.paths,
        t.mainFields,
        t.addMatchAll
      );
      const result = matchPath(
        t.requestedModule,
        (_: string) => t.packageJson,
        (name: string) => t.existingFiles.indexOf(name) !== -1,
        t.extensions
      );
      // assert.equal(result, t.expectedPath);
      expect(result).toBe(t.expectedPath);
    })
  );
});

================================================================================
File: ./node_modules/tsconfig-paths/src/__tests__/match-path-async.test.ts
================================================================================

import { createMatchPathAsync } from "../match-path-async";
import * as Tests from "./data/match-path-data";

describe("match-path-async", () => {
  Tests.tests.forEach((t) =>
    it(t.name, (done) => {
      const matchPath = createMatchPathAsync(
        t.absoluteBaseUrl,
        t.paths,
        t.mainFields,
        t.addMatchAll
      );
      matchPath(
        t.requestedModule,
        (_path, callback) => callback(undefined, t.packageJson),
        (path, callback) =>
          callback(undefined, t.existingFiles.indexOf(path) !== -1),
        t.extensions,
        (_err, result) => {
          // assert.equal(result, t.expectedPath);
          expect(result).toBe(t.expectedPath);
          done();
        }
      );
    })
  );
});

================================================================================
File: ./node_modules/tsconfig-paths/src/__tests__/try-path.test.ts
================================================================================

import { getPathsToTry } from "../try-path";
import { join } from "path";

describe("mapping-entry", () => {
  const abosolutePathMappings = [
    {
      pattern: "longest/pre/fix/*",
      paths: [join("/absolute", "base", "url", "foo2", "bar")],
    },
    { pattern: "pre/fix/*", paths: [join("/absolute", "base", "url", "foo3")] },
    { pattern: "*", paths: [join("/absolute", "base", "url", "foo1")] },
  ];
  const abosolutePathMappingsStarstWithSlash = [
    {
      pattern: "/opt/*",
      paths: [join("/absolute", "src", "aws-layer")],
    },
    {
      pattern: "*",
      paths: [join("/absolute", "src")],
    },
  ];
  it("should return no paths for relative requested module", () => {
    const result = getPathsToTry(
      [".ts", "tsx"],
      abosolutePathMappings,
      "./requested-module"
    );
    // assert.deepEqual(result, undefined);
    expect(result).toBeUndefined();
  });

  it("should return no paths if no pattern match the requested module", () => {
    const result = getPathsToTry(
      [".ts", "tsx"],
      [
        {
          pattern: "longest/pre/fix/*",
          paths: [join("/absolute", "base", "url", "foo2", "bar")],
        },
        {
          pattern: "pre/fix/*",
          paths: [join("/absolute", "base", "url", "foo3")],
        },
      ],
      "requested-module"
    );
    expect(result).toBeUndefined();
  });

  it("should get all paths that matches requested module", () => {
    const result = getPathsToTry(
      [".ts", ".tsx"],
      abosolutePathMappings,
      "longest/pre/fix/requested-module"
    );
    // assert.deepEqual(result, [
    //   // "longest/pre/fix/*"
    //   { type: "file", path: join("/absolute", "base", "url", "foo2", "bar") },
    //   {
    //     type: "extension",
    //     path: join("/absolute", "base", "url", "foo2", "bar.ts"),
    //   },
    //   {
    //     type: "extension",
    //     path: join("/absolute", "base", "url", "foo2", "bar.tsx"),
    //   },
    //   {
    //     type: "package",
    //     path: join("/absolute", "base", "url", "foo2", "bar", "package.json"),
    //   },
    //   {
    //     type: "index",
    //     path: join("/absolute", "base", "url", "foo2", "bar", "index.ts"),
    //   },
    //   {
    //     type: "index",
    //     path: join("/absolute", "base", "url", "foo2", "bar", "index.tsx"),
    //   },
    //   // "*"
    //   { type: "file", path: join("/absolute", "base", "url", "foo1") },
    //   { type: "extension", path: join("/absolute", "base", "url", "foo1.ts") },
    //   { type: "extension", path: join("/absolute", "base", "url", "foo1.tsx") },
    //   {
    //     type: "package",
    //     path: join("/absolute", "base", "url", "foo1", "package.json"),
    //   },
    //   {
    //     type: "index",
    //     path: join("/absolute", "base", "url", "foo1", "index.ts"),
    //   },
    //   {
    //     type: "index",
    //     path: join("/absolute", "base", "url", "foo1", "index.tsx"),
    //   },
    // ]);
    expect(result).toEqual([
      // "longest/pre/fix/*"
      { type: "file", path: join("/absolute", "base", "url", "foo2", "bar") },
      {
        type: "extension",
        path: join("/absolute", "base", "url", "foo2", "bar.ts"),
      },
      {
        type: "extension",
        path: join("/absolute", "base", "url", "foo2", "bar.tsx"),
      },
      {
        type: "package",
        path: join("/absolute", "base", "url", "foo2", "bar", "package.json"),
      },
      {
        type: "index",
        path: join("/absolute", "base", "url", "foo2", "bar", "index.ts"),
      },
      {
        type: "index",
        path: join("/absolute", "base", "url", "foo2", "bar", "index.tsx"),
      },
      // "*"
      { type: "file", path: join("/absolute", "base", "url", "foo1") },
      { type: "extension", path: join("/absolute", "base", "url", "foo1.ts") },
      { type: "extension", path: join("/absolute", "base", "url", "foo1.tsx") },
      {
        type: "package",
        path: join("/absolute", "base", "url", "foo1", "package.json"),
      },
      {
        type: "index",
        path: join("/absolute", "base", "url", "foo1", "index.ts"),
      },
      {
        type: "index",
        path: join("/absolute", "base", "url", "foo1", "index.tsx"),
      },
    ]);
  });

  it("should resolve paths starting with a slash", () => {
    const result = getPathsToTry(
      [".ts"],
      abosolutePathMappingsStarstWithSlash,
      "/opt/utils"
    );
    expect(result).toEqual([
      // "opt/*"
      {
        path: join("/absolute", "src", "aws-layer"),
        type: "file",
      },
      {
        path: join("/absolute", "src", "aws-layer.ts"),
        type: "extension",
      },
      {
        path: join("/absolute", "src", "aws-layer", "package.json"),
        type: "package",
      },
      {
        path: join("/absolute", "src", "aws-layer", "index.ts"),
        type: "index",
      },
      // "*"
      {
        path: join("/absolute", "src"),
        type: "file",
      },
      {
        path: join("/absolute", "src.ts"),
        type: "extension",
      },
      {
        path: join("/absolute", "src", "package.json"),
        type: "package",
      },
      {
        path: join("/absolute", "src", "index.ts"),
        type: "index",
      },
    ]);
  });
});

// describe("match-star", () => {
//   it("should match star in last position", () => {
//     const result = matchStar("lib/*", "lib/mylib");
//     assert.equal(result, "mylib");
//   });
//   it("should match star in first position", () => {
//     const result = matchStar("*/lib", "mylib/lib");
//     assert.equal(result, "mylib");
//   });
// });

================================================================================
File: ./node_modules/tsconfig-paths/src/__tests__/config-loader.test.ts
================================================================================

import {
  configLoader,
  loadConfig,
  ConfigLoaderFailResult,
  ConfigLoaderSuccessResult,
} from "../config-loader";
import { join } from "path";

describe("config-loader", (): void => {
  it("should use explicitParams when set", () => {
    const result = configLoader({
      explicitParams: {
        baseUrl: "/foo/bar",
        paths: {
          asd: ["asd"],
        },
      },
      cwd: "/baz",
    });

    const successResult = result as ConfigLoaderSuccessResult;
    // assert.equal(successResult.resultType, "success");
    // assert.equal(successResult.absoluteBaseUrl, "/foo/bar");
    // assert.equal(successResult.paths["asd"][0], "asd");
    expect(successResult.resultType).toBe("success");
    expect(successResult.absoluteBaseUrl).toBe("/foo/bar");
    expect(successResult.paths["asd"][0]).toBe("asd");
  });

  it("should use explicitParams when set and add cwd when path is relative", () => {
    const result = configLoader({
      explicitParams: {
        baseUrl: "bar/",
        paths: {
          asd: ["asd"],
        },
      },
      cwd: "/baz",
    });

    const successResult = result as ConfigLoaderSuccessResult;
    // assert.equal(successResult.resultType, "success");
    // assert.equal(successResult.absoluteBaseUrl, join("/baz", "bar/"));
    expect(successResult.resultType).toBe("success");
    expect(successResult.absoluteBaseUrl).toBe(join("/baz", "bar/"));
  });

  it("should fallback to tsConfigLoader when explicitParams is not set", () => {
    const result = configLoader({
      explicitParams: undefined,
      cwd: "/baz",
      // tslint:disable-next-line:no-any
      tsConfigLoader: (_: any) => ({
        tsConfigPath: "/baz/tsconfig.json",
        baseUrl: "./src",
        paths: {},
      }),
    });

    const successResult = result as ConfigLoaderSuccessResult;
    // assert.equal(successResult.resultType, "success");
    // assert.equal(successResult.absoluteBaseUrl, join("/baz", "src"));
    expect(successResult.resultType).toBe("success");
    expect(successResult.absoluteBaseUrl).toBe(join("/baz", "src"));
  });

  it("should show an error message when baseUrl is missing", () => {
    const result = configLoader({
      explicitParams: undefined,
      cwd: "/baz",
      // tslint:disable-next-line:no-any
      tsConfigLoader: (_: any) => ({
        tsConfigPath: "/baz/tsconfig.json",
        baseUrl: undefined,
        paths: {},
      }),
    });

    const failResult = result as ConfigLoaderFailResult;
    // assert.equal(failResult.resultType, "failed");
    // assert.isTrue(failResult.message.indexOf("baseUrl") > -1);
    expect(failResult.resultType).toBe("failed");
    expect(failResult.message.indexOf("baseUrl") > -1).toBeTruthy();
  });

  it("should presume cwd to be a tsconfig file when loadConfig is called with absolute path to tsconfig.json", () => {
    // using tsconfig-named.json to ensure that future changes to fix
    // https://github.com/dividab/tsconfig-paths/issues/31
    // do not pass this test case just because of a directory walk looking
    // for tsconfig.json
    const configFile = join(__dirname, "tsconfig-named.json");
    const result = loadConfig(configFile);

    const successResult = result as ConfigLoaderSuccessResult;
    // assert.equal(successResult.resultType, "success");
    // assert.equal(successResult.configFileAbsolutePath, configFile);
    expect(successResult.resultType).toBe("success");
    expect(successResult.configFileAbsolutePath).toBe(configFile);
  });
});

================================================================================
File: ./node_modules/tsconfig-paths/src/__tests__/mapping-entry.test.ts
================================================================================

import { getAbsoluteMappingEntries } from "../mapping-entry";
import { join } from "path";

describe("mapping-entry", () => {
  it("should change to absolute paths and sort in longest prefix order", () => {
    const result = getAbsoluteMappingEntries(
      "/absolute/base/url",
      {
        "*": ["/foo1", "/foo2"],
        "longest/pre/fix/*": ["/foo2/bar"],
        "pre/fix/*": ["/foo3"],
      },
      true
    );
    // assert.deepEqual(result, [
    //   {
    //     pattern: "longest/pre/fix/*",
    //     paths: [join("/absolute", "base", "url", "foo2", "bar")],
    //   },
    //   {
    //     pattern: "pre/fix/*",
    //     paths: [join("/absolute", "base", "url", "foo3")],
    //   },
    //   {
    //     pattern: "*",
    //     paths: [
    //       join("/absolute", "base", "url", "foo1"),
    //       join("/absolute", "base", "url", "foo2"),
    //     ],
    //   },
    // ]);
    expect(result).toEqual([
      {
        pattern: "longest/pre/fix/*",
        paths: [join("/absolute", "base", "url", "foo2", "bar")],
      },
      {
        pattern: "pre/fix/*",
        paths: [join("/absolute", "base", "url", "foo3")],
      },
      {
        pattern: "*",
        paths: [
          join("/absolute", "base", "url", "foo1"),
          join("/absolute", "base", "url", "foo2"),
        ],
      },
    ]);
  });

  it("should should add a match-all pattern when requested", () => {
    let result = getAbsoluteMappingEntries("/absolute/base/url", {}, true);
    // assert.deepEqual(result, [
    //   {
    //     pattern: "*",
    //     paths: [join("/absolute", "base", "url", "*")],
    //   },
    // ]);
    expect(result).toEqual([
      {
        pattern: "*",
        paths: [join("/absolute", "base", "url", "*")],
      },
    ]);

    result = getAbsoluteMappingEntries("/absolute/base/url", {}, false);
    // assert.deepEqual(result, []);
    expect(result).toEqual([]);
  });
});

================================================================================
File: ./node_modules/tsconfig-paths/src/__tests__/tsconfig-loader.test.ts
================================================================================

import {
  loadTsconfig,
  tsConfigLoader,
  walkForTsConfig,
} from "../tsconfig-loader";
import { join } from "path";

describe("tsconfig-loader", () => {
  it("should find tsconfig in cwd", () => {
    const result = tsConfigLoader({
      cwd: "/foo/bar",
      getEnv: (_: string) => undefined,
      loadSync: (cwd: string) => {
        return {
          tsConfigPath: `${cwd}/tsconfig.json`,
          baseUrl: "./",
          paths: {},
        };
      },
    });

    // assert.equal(result.tsConfigPath, "/foo/bar/tsconfig.json");
    expect(result.tsConfigPath).toBe("/foo/bar/tsconfig.json");
  });

  it("should return loaderResult.tsConfigPath as undefined when not found", () => {
    const result = tsConfigLoader({
      cwd: "/foo/bar",
      getEnv: (_: string) => undefined,
      loadSync: (_: string) => {
        return {
          tsConfigPath: undefined,
          baseUrl: "./",
          paths: {},
        };
      },
    });

    // assert.isUndefined(result.tsConfigPath);
    expect(result.tsConfigPath).toBeUndefined();
  });

  it("should use TS_NODE_PROJECT env if exists", () => {
    const result = tsConfigLoader({
      cwd: "/foo/bar",
      getEnv: (key: string) =>
        key === "TS_NODE_PROJECT" ? "/foo/baz" : undefined,
      loadSync: (cwd: string, fileName: string) => {
        if (cwd === "/foo/bar" && fileName === "/foo/baz") {
          return {
            tsConfigPath: "/foo/baz/tsconfig.json",
            baseUrl: "./",
            paths: {},
          };
        }

        return {
          tsConfigPath: undefined,
          baseUrl: "./",
          paths: {},
        };
      },
    });

    // assert.equal(result.tsConfigPath, "/foo/baz/tsconfig.json");
    expect(result.tsConfigPath).toBe("/foo/baz/tsconfig.json");
  });

  it("should use TS_NODE_BASEURL env if exists", () => {
    const result = tsConfigLoader({
      cwd: "/foo/bar",
      getEnv: (key: string) =>
        key === "TS_NODE_BASEURL" ? "SOME_BASEURL" : undefined,
      loadSync: (_0: string, _1: string, baseUrl: string) => {
        return {
          tsConfigPath: undefined,
          baseUrl,
          paths: {},
        };
      },
    });

    // assert.equal(result.baseUrl, "SOME_BASEURL");
    expect(result.baseUrl).toBe("SOME_BASEURL");
  });

  it("should not use TS_NODE_BASEURL env if it does not exist", () => {
    const result = tsConfigLoader({
      cwd: "/foo/bar",
      getEnv: (_: string) => {
        return undefined;
      },
      loadSync: (_0: string, _1: string, baseUrl: string) => {
        return {
          tsConfigPath: undefined,
          baseUrl,
          paths: {},
        };
      },
    });

    // assert.equal(result.baseUrl, undefined);
    expect(result.baseUrl).toBeUndefined();
  });
});

describe("walkForTsConfig", () => {
  it("should find tsconfig in starting directory", () => {
    const pathToTsconfig = join("/root", "dir1", "tsconfig.json");
    const res = walkForTsConfig(
      join("/root", "dir1"),
      (path) => path === pathToTsconfig
    );
    // assert.equal(res, pathToTsconfig);
    expect(res).toBe(pathToTsconfig);
  });

  it("should find tsconfig in parent directory", () => {
    const pathToTsconfig = join("/root", "tsconfig.json");
    const res = walkForTsConfig(
      join("/root", "dir1"),
      (path) => path === pathToTsconfig
    );
    // assert.equal(res, pathToTsconfig);
    expect(res).toBe(pathToTsconfig);
  });

  it("should return undefined when reaching the top", () => {
    const res = walkForTsConfig(join("/root", "dir1", "kalle"), () => false);
    // assert.equal(res, undefined);
    expect(res).toBeUndefined();
  });
});

describe("loadConfig", () => {
  it("should load a config", () => {
    const config = { compilerOptions: { baseUrl: "hej" } };
    const res = loadTsconfig(
      "/root/dir1/tsconfig.json",
      (path) => path === "/root/dir1/tsconfig.json",
      (_) => JSON.stringify(config)
    );
    // assert.deepEqual(res, config);
    expect(res).toStrictEqual(config);
  });

  it("should load a config with comments", () => {
    const config = { compilerOptions: { baseUrl: "hej" } };
    const res = loadTsconfig(
      "/root/dir1/tsconfig.json",
      (path) => path === "/root/dir1/tsconfig.json",
      (_) => `{
          // my comment
          "compilerOptions": { 
            "baseUrl": "hej"
          }
        }`
    );
    // assert.deepEqual(res, config);
    expect(res).toStrictEqual(config);
  });

  it("should load a config with trailing commas", () => {
    const config = { compilerOptions: { baseUrl: "hej" } };
    const res = loadTsconfig(
      "/root/dir1/tsconfig.json",
      (path) => path === "/root/dir1/tsconfig.json",
      (_) => `{
          "compilerOptions": { 
            "baseUrl": "hej",
          },
        }`
    );
    // assert.deepEqual(res, config);
    expect(res).toStrictEqual(config);
  });

  it("should throw an error including the file path when encountering invalid JSON5", () => {
    expect(() =>
      loadTsconfig(
        "/root/dir1/tsconfig.json",
        (path) => path === "/root/dir1/tsconfig.json",
        (_) => `{
            "compilerOptions": {
          }`
      )
    ).toThrowError(
      "/root/dir1/tsconfig.json is malformed JSON5: invalid end of input at 3:12"
    );
  });

  it("should load a config with string extends and overwrite all options", () => {
    const firstConfig = {
      extends: "../base-config.json",
      compilerOptions: { baseUrl: "kalle", paths: { foo: ["bar2"] } },
    };
    const firstConfigPath = join("/root", "dir1", "tsconfig.json");
    const baseConfig = {
      compilerOptions: {
        baseUrl: "olle",
        paths: { foo: ["bar1"] },
        strict: true,
      },
    };
    const baseConfigPath = join("/root", "base-config.json");
    const res = loadTsconfig(
      join("/root", "dir1", "tsconfig.json"),
      (path) => path === firstConfigPath || path === baseConfigPath,
      (path) => {
        if (path === firstConfigPath) {
          return JSON.stringify(firstConfig);
        }
        if (path === baseConfigPath) {
          return JSON.stringify(baseConfig);
        }
        return "";
      }
    );

    // assert.deepEqual(res, {
    //   extends: "../base-config.json",
    //   compilerOptions: {
    //     baseUrl: "kalle",
    //     paths: { foo: ["bar2"] },
    //     strict: true,
    //   },
    // });
    expect(res).toEqual({
      extends: "../base-config.json",
      compilerOptions: {
        baseUrl: "kalle",
        paths: { foo: ["bar2"] },
        strict: true,
      },
    });
  });

  it("should load a config with string extends from node_modules and overwrite all options", () => {
    const firstConfig = {
      extends: "my-package/base-config.json",
      compilerOptions: { baseUrl: "kalle", paths: { foo: ["bar2"] } },
    };
    const firstConfigPath = join("/root", "dir1", "tsconfig.json");
    const baseConfig = {
      compilerOptions: {
        baseUrl: "olle",
        paths: { foo: ["bar1"] },
        strict: true,
      },
    };
    const baseConfigPath = join(
      "/root",
      "dir1",
      "node_modules",
      "my-package",
      "base-config.json"
    );
    const res = loadTsconfig(
      join("/root", "dir1", "tsconfig.json"),
      (path) => path === firstConfigPath || path === baseConfigPath,
      (path) => {
        if (path === firstConfigPath) {
          return JSON.stringify(firstConfig);
        }
        if (path === baseConfigPath) {
          return JSON.stringify(baseConfig);
        }
        return "";
      }
    );

    // assert.deepEqual(res, {
    //   extends: "my-package/base-config.json",
    //   compilerOptions: {
    //     baseUrl: "kalle",
    //     paths: { foo: ["bar2"] },
    //     strict: true,
    //   },
    // });
    expect(res).toEqual({
      extends: "my-package/base-config.json",
      compilerOptions: {
        baseUrl: "kalle",
        paths: { foo: ["bar2"] },
        strict: true,
      },
    });
  });

  it("should use baseUrl relative to location of extended tsconfig", () => {
    const firstConfig = { compilerOptions: { baseUrl: "." } };
    const firstConfigPath = join("/root", "first-config.json");
    const secondConfig = { extends: "../first-config.json" };
    const secondConfigPath = join("/root", "dir1", "second-config.json");
    const thirdConfig = { extends: "../second-config.json" };
    const thirdConfigPath = join("/root", "dir1", "dir2", "third-config.json");
    const res = loadTsconfig(
      join("/root", "dir1", "dir2", "third-config.json"),
      (path) =>
        path === firstConfigPath ||
        path === secondConfigPath ||
        path === thirdConfigPath,
      (path) => {
        if (path === firstConfigPath) {
          return JSON.stringify(firstConfig);
        }
        if (path === secondConfigPath) {
          return JSON.stringify(secondConfig);
        }
        if (path === thirdConfigPath) {
          return JSON.stringify(thirdConfig);
        }
        return "";
      }
    );

    // assert.deepEqual(res, {
    //   extends: "../second-config.json",
    //   compilerOptions: { baseUrl: join("..", "..") },
    // });
    expect(res).toEqual({
      extends: "../second-config.json",
      compilerOptions: { baseUrl: join("..", "..") },
    });
  });

  it("should load a config with array extends and overwrite all options", () => {
    const baseConfig1 = {
      compilerOptions: { baseUrl: ".", paths: { foo: ["bar"] } },
    };
    const baseConfig1Path = join("/root", "base-config-1.json");
    const baseConfig2 = { compilerOptions: { baseUrl: "." } };
    const baseConfig2Path = join("/root", "dir1", "base-config-2.json");
    const baseConfig3 = {
      compilerOptions: { baseUrl: ".", paths: { foo: ["bar2"] } },
    };
    const baseConfig3Path = join("/root", "dir1", "dir2", "base-config-3.json");
    const actualConfig = {
      extends: [
        "./base-config-1.json",
        "./dir1/base-config-2.json",
        "./dir1/dir2/base-config-3.json",
      ],
    };
    const actualConfigPath = join("/root", "tsconfig.json");

    const res = loadTsconfig(
      join("/root", "tsconfig.json"),
      (path) =>
        [
          baseConfig1Path,
          baseConfig2Path,
          baseConfig3Path,
          actualConfigPath,
        ].indexOf(path) >= 0,
      (path) => {
        if (path === baseConfig1Path) {
          return JSON.stringify(baseConfig1);
        }
        if (path === baseConfig2Path) {
          return JSON.stringify(baseConfig2);
        }
        if (path === baseConfig3Path) {
          return JSON.stringify(baseConfig3);
        }
        if (path === actualConfigPath) {
          return JSON.stringify(actualConfig);
        }
        return "";
      }
    );

    expect(res).toEqual({
      extends: [
        "./base-config-1.json",
        "./dir1/base-config-2.json",
        "./dir1/dir2/base-config-3.json",
      ],
      compilerOptions: {
        baseUrl: join("dir1", "dir2"),
        paths: { foo: ["bar2"] },
      },
    });
  });

  it("should load a config with array extends without .json extension", () => {
    const baseConfig = {
      compilerOptions: { baseUrl: ".", paths: { foo: ["bar"] } },
    };
    const baseConfigPath = join("/root", "base-config-1.json");
    const actualConfig = { extends: ["./base-config-1"] };
    const actualConfigPath = join("/root", "tsconfig.json");

    const res = loadTsconfig(
      join("/root", "tsconfig.json"),
      (path) => [baseConfigPath, actualConfigPath].indexOf(path) >= 0,
      (path) => {
        if (path === baseConfigPath) {
          return JSON.stringify(baseConfig);
        }
        if (path === actualConfigPath) {
          return JSON.stringify(actualConfig);
        }
        return "";
      }
    );

    expect(res).toEqual({
      extends: ["./base-config-1"],
      compilerOptions: {
        baseUrl: ".",
        paths: { foo: ["bar"] },
      },
    });
  });
});

================================================================================
File: ./node_modules/tsconfig-paths/src/__tests__/filesystem.test.ts
================================================================================

import * as Filesystem from "../filesystem";
import * as path from "path";

describe("filesystem", () => {
  const fileThatExists = path.join(__dirname, "../../package.json");
  const fileThatNotExists = path.join(__dirname, "../../package2.json");

  it("should find file that exists, sync", () => {
    const result = Filesystem.fileExistsSync(fileThatExists);
    // assert.equal(result, true);
    expect(result).toBe(true);
  });

  it("should not find file that not exists, sync", () => {
    const result = Filesystem.fileExistsSync(fileThatNotExists);
    // assert.equal(result, false);
    expect(result).toBe(false);
  });

  it("should find file that exists, async", (done) => {
    Filesystem.fileExistsAsync(fileThatExists, (_err, result) => {
      try {
        // assert.equal(result, true);
        expect(result).toBe(true);
        done();
      } catch (error) {
        done(error);
      }
    });
  });

  it("should not find file that not exists, async", (done) => {
    Filesystem.fileExistsAsync(fileThatNotExists, (_err, result) => {
      try {
        // assert.equal(result, false);
        expect(result).toBe(false);
        done();
      } catch (error) {
        done(error);
      }
    });
  });

  it("should load json, sync", () => {
    const result = Filesystem.readJsonFromDiskSync(fileThatExists);
    // assert.isOk(result);
    expect(result);
    // assert.equal(result.main, "lib/index.js");
    expect(result.main).toBe("lib/index.js");
  });

  it("should load json, async", (done) => {
    Filesystem.readJsonFromDiskAsync(fileThatExists, (_err, result) => {
      try {
        // assert.isOk(result); // Asserts that object is truthy.
        expect(result).toBeTruthy();
        // assert.equal(result.main, "lib/index.js");
        expect(result.main).toBe("lib/index.js");
        done();
      } catch (error) {
        done(error);
      }
    });
  });
});

================================================================================
File: ./node_modules/rehype-ignore/src/__test__/index.test.ts
================================================================================

import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remark2rehype from 'remark-rehype';
import { rehype } from 'rehype';
import rehypeRaw from 'rehype-raw';
import stringify from 'rehype-stringify';
import rehypeIgnore from '../index.js';

it('rehypeIgnore markdown raw test case 1', async () => {
  const markdown = `<!--rehype:ignore:start-->\n# Title\n<!--rehype:ignore:end-->\n\ntest`;
  const htmlStr = unified()
    .use(remarkParse)
    .use(remark2rehype, { allowDangerousHtml: true })
    .use(rehypeIgnore, { })
    .use(stringify)
    .processSync(markdown)
    .toString()
    expect(htmlStr).toEqual('\n<p>test</p>');
});

it('rehypeIgnore test case 1', async () => {
  const html = `<!--rehype:ignore:start--><h1>header</h1><!--rehype:ignore:end-->`;
  const htmlStr = rehype()
    .data('settings', { fragment: true })
    .use(rehypeIgnore, { })
    .use(stringify)
    .processSync(html)
    .toString()
    expect(htmlStr).toEqual('');
});

it('rehypeIgnore test case 2', async () => {
  const html = `<!--rehype:ignore:start--><h1>header</h1>`;
  const htmlStr = rehype()
    .data('settings', { fragment: true })
    .use(rehypeIgnore, { })
    .use(stringify)
    .processSync(html)
    .toString()
    expect(htmlStr).toEqual('');
});

it('rehypeIgnore test case 3', async () => {
  const html = `<h1>header</h1><!--rehype:ignore:end-->`;
  const htmlStr = rehype()
    .data('settings', { fragment: true })
    .use(rehypeIgnore, { })
    .use(stringify)
    .processSync(html)
    .toString()
    expect(htmlStr).toEqual('<h1>header</h1>');
});

it('rehypeIgnore test case 4', async () => {
  const html = `<!--rehype:ignore:start--><h1>header</h1><!--rehype:ignore:end--><!--rehype:ignore:end-->`;
  const htmlStr = rehype()
    .data('settings', { fragment: true })
    .use(rehypeIgnore, { })
    .use(stringify)
    .processSync(html)
    .toString()
    expect(htmlStr).toEqual('');
});

it('rehypeIgnore Markdown test case', async () => {
  const html = `# Hello World

<!--rehype:ignore:start-->Hello World<!--rehype:ignore:end-->

Good!`;
  const expected = `<h1>Hello World</h1>

<p>Good!</p>`;
  const htmlStr = unified()
    .use(remarkParse)
    .use(remark2rehype, { allowDangerousHtml: true })
    .use(rehypeRaw)
    .use(rehypeIgnore, { })
    .use(stringify)
    .processSync(html)
    .toString()

    expect(htmlStr).toEqual(expected);
});

it('rehypeIgnore test case openDelimiter/closeDelimiter', async () => {
  const html = `<!--idoc:start--><h1>header</h1><!--idoc:end-->`;
  const htmlStr = rehype()
    .data('settings', { fragment: true })
    .use(rehypeIgnore, {
      openDelimiter: 'idoc:start',
      closeDelimiter: 'idoc:end',
    })
    .use(stringify)
    .processSync(html)
    .toString()
    expect(htmlStr).toEqual('');
});

it('rehypeIgnore test case', async () => {
  const html = `<!--rehype:ignore:start-->
<h1>header</h1>
<!--rehype:ignore:end-->
<p>
  Hello <!--rehype:ignore:start--> <code>World</code> <!--rehype:ignore:end-->
</p>

<!--rehype:ignore:start-->
<h2>header</h2>
<!--rehype:ignore:end-->
<p>Hi</p>
`;
  const expected = `
<p>
  Hello 
</p>


<p>Hi</p>
`;
  const htmlStr = rehype()
    .data('settings', { fragment: true })
    .use(rehypeIgnore, { })
    .use(stringify)
    .processSync(html)
    .toString()
    expect(htmlStr).toEqual(expected);
});

================================================================================
File: ./node_modules/rehype-rewrite/src/__tests__/index.test.ts
================================================================================

import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remark2rehype from 'remark-rehype';
import { rehype } from 'rehype';
import rehypeRaw from 'rehype-raw';
import stringify from 'rehype-stringify';
import rehypeRewrite, { getCodeString } from '../index.js';

describe('getCodeString test case', () => {
  it('selector options', async () => {
    const str = getCodeString([
      {
        type: 'text',
        value: 'Hello'
      },
      {
        type: 'element',
        tagName: 'span',
        properties: {
          class: 'octicon octicon-link',
        },
        children: [
          {
            type: 'text',
            value: 'World'
          },
        ]
      }
    ]);
    expect(str).toEqual('HelloWorld');
    expect(getCodeString()).toEqual('');
    expect(getCodeString(undefined, 'good')).toEqual('good');
  });
})

describe('rehype-rewrite test case', () => {
  it('selector options', async () => {
    const html = `<h1>header</h1>`;
    const expected = `<h1 class="test">header</h1>`
    const htmlStr = rehype()
      .data('settings', { fragment: true })
      .use(rehypeRewrite, {
        selector: 'h1',
        rewrite: (node) => {
          if (node.type === 'element') {
            node.properties = { ...node.properties, class: 'test' }
          }
        }
      })
      .use(stringify)
      .processSync(html)
      .toString()

      expect(htmlStr).toEqual(expected);
  });

  it('selector options', async () => {
    const html = `<h1>header</h1><h1>header</h1><h1 class="title3">header</h1>`;
    const expected = `<h1 class="test">header</h1><h1 class="test">header</h1><h1 class="test">header</h1>`
    const htmlStr = rehype()
      .data('settings', { fragment: true })
      .use(rehypeRewrite, {
        selector: 'h1',
        rewrite: (node) => {
          if (node.type === 'element') {
            node.properties!.className = 'test';
          }
        }
      })
      .use(stringify)
      .processSync(html)
      .toString()

      expect(htmlStr).toEqual(expected);
  });

  it('selector = undefined', async () => {
    const html = `<h1>header</h1>`;
    const expected = `<h1>header</h1>`
    const htmlStr = rehype()
      .data('settings', { fragment: true })
      .use(rehypeRewrite, {
        selector: 'h1.good',
        rewrite: (node) => {
          if (node.type === 'element') {
            node.properties = { ...node.properties, class: 'test' }
          }
        }
      })
      .use(stringify)
      .processSync(html)
      .toString()

      expect(htmlStr).toEqual(expected);
  });

  it('selector = undefined', async () => {
    const html = `<h1>header</h1>`;
    const expected = `<h1>header</h1>`
    const htmlStr = rehype()
      .data('settings', { fragment: true })
      .use(rehypeRewrite)
      .use(stringify)
      .processSync(html)
      .toString()

      expect(htmlStr).toEqual(expected);
  });

  it('remove text', async () => {
    const html = `<h1>header</h1>`;
    const expected = `<h1></h1>`
    const htmlStr = rehype()
      .data('settings', { fragment: true })
      .use(rehypeRewrite, {
        rewrite: (node) => {
          if(node.type == 'text' && node.value == 'header') {
            node.value = ''
          }
        }
      })
      .use(stringify)
      .processSync(html)
      .toString()

      expect(htmlStr).toEqual(expected);
  });

  it('modify properties', async () => {
    const html = `<h1>header</h1>`;
    const expected = `<html><head></head><body style="color:red;"><h1>header</h1></body></html>`
    const htmlStr = rehype()
      .use(rehypeRewrite, {
        rewrite: (node) => {
          if (node.type == 'element' && node.tagName == 'body') {
            node.properties = { ...node.properties, style: 'color:red;'}
          }
        }
      })
      .use(stringify)
      .processSync(html)
      .toString()

      expect(htmlStr).toEqual(expected);
  });

  it('add element', async () => {
    const html = `<h1>hello</h1>`;
    const expected = `<h1>hello<span> world</span></h1>`
    const htmlStr = rehype()
      .data('settings', { fragment: true })
      .use(rehypeRewrite, {
        rewrite: (node) => {
          if (node.type == 'element' && node.tagName == 'h1') {
            node.children = [ ...node.children, {
              type: 'element',
              tagName: 'span',
              properties: {},
              children: [
                {type: 'text', value: ' world'}
              ]
            }]
          }
        }
      })
      .use(stringify)
      .processSync(html)
      .toString()
      
      expect(htmlStr).toEqual(expected);
  });

  it('use unified', async () => {
    const markdown = "Hello World!"
    const expected = `<p style="color:red;">Hello World!</p>`
    const htmlStr = unified()
      .use(remarkParse)
      .use(remark2rehype, { allowDangerousHtml: true })
      .use(rehypeRaw)
      .use(rehypeRewrite, {
        rewrite: (node) => {
          if (node.type == 'element' && node.tagName == 'p') {
            node.properties = { ...node.properties, style: 'color:red;' }
          }
        }
      })
      .use(stringify)
      .processSync(markdown)
      .toString()

      expect(htmlStr).toEqual(expected);
  });

  it('options parameter test', async () => {
    const markdown = "Hello World!"
    const expected = `Hello World!`
    const htmlStr = rehype()
      .data('settings', { fragment: true })
      .use(rehypeRewrite, {} as any)
      .use(stringify)
      .processSync(markdown)
      .toString()

      expect(htmlStr).toEqual(expected);
  });
});


================================================================================
File: ./repro.v6.test.ts
================================================================================

// repro.v6.test.ts
describe('Remark ESM V6', () => {
  it('converts markdown to HTML correctly', async () => {
    try {
      console.debug('[V6] Beginning dynamic import of "remark".');
      const modRemark = await import('remark');
      const remarkFn = modRemark.remark;
      if (!remarkFn) {
        throw new Error('[V6] "remark" function missing.');
      }
      console.debug('[V6] "remark" imported successfully.');

      console.debug('[V6] Importing "remark-html".');
      const modRemarkHtml = await import('remark-html');
      const remarkHtmlFn = modRemarkHtml.default || modRemarkHtml;
      if (!remarkHtmlFn) {
        throw new Error('[V6] "remark-html" export missing.');
      }
      console.debug('[V6] "remark-html" imported successfully.');

      const markdownInput = '# V6 Test Markdown';
      console.debug('[V6] Processing markdown:', markdownInput);

      const result = await remarkFn().use(remarkHtmlFn).process(markdownInput);
      const htmlResult = result.toString();
      console.debug('[V6] HTML output:', htmlResult);

      expect(htmlResult).toContain('<h1>V6 Test Markdown</h1>');
    } catch (e) {
      console.error('[V6] Error during transformation:', e);
      throw e;
    }
  });
});

================================================================================
File: ./repro.v2.test.ts
================================================================================

// repro.v2.test.ts
describe('Remark ESM V2 Repro', () => {
  it('should transform markdown into HTML correctly', async () => {
    try {
      console.debug('[V2 Test] Initiating dynamic import for remark module.');
      const { remark: rmFunction } = await import('remark');
      if (!rmFunction) {
        throw new Error('[V2 Test] "remark" export not found in the remark module.');
      }
      console.debug('[V2 Test] Successfully loaded remark:', rmFunction);

      console.debug('[V2 Test] Importing remark-html module.');
      const htmlMod = await import('remark-html');
      const htmlTransformer = (htmlMod as { default: unknown }).default;
      if (!htmlTransformer) {
        throw new Error('[V2 Test] Default export missing in remark-html module.');
      }
      console.debug('[V2 Test] Successfully loaded remark-html:', htmlTransformer);

      console.debug('[V2 Test] Processing markdown input.');
      const mdInput = '# Test Markdown';
      const processedResult = await rmFunction().use(htmlTransformer).process(mdInput);
      const htmlOutput = processedResult.toString();
      console.debug('[V2 Test] Final HTML output:', htmlOutput);

      expect(htmlOutput).toContain('<h1>Test Markdown</h1>');
    } catch (err) {
      console.error('[V2 Test] Error during markdown transformation:', err);
      throw err;
    }
  });
});

================================================================================
File: ./__tests__/data.test.ts
================================================================================

// __tests__/data.test.ts
import { courses } from '@/data';
import { Course } from '@/types';

describe('Data Generation', () => {
  it('should generate courses with all required properties', () => {
    expect(courses).toBeInstanceOf(Array);
    courses.forEach((course: Course) => {
      expect(course).toHaveProperty('id');
      expect(course).toHaveProperty('title');
      expect(course).toHaveProperty('imageUrl'); // Verify updated property name
      expect(course).toHaveProperty('schedule');
      expect(course).toHaveProperty('level');
      expect(course).toHaveProperty('language');
      expect(course).toHaveProperty('startDate');
      expect(course).toHaveProperty('duration');
      expect(course).toHaveProperty('maxStudents');
      expect(course).toHaveProperty('price');
      expect(course).toHaveProperty('description');
    });
  });
});

================================================================================
File: ./__tests__/rssXml.test.ts
================================================================================

// __tests__/rssXml.test.ts
import { getServerSideProps } from '@/pages/rss.xml';
import { NextApiResponse } from 'next';

describe('RSS XML Page', () => {
  it('should set proper headers and return empty props', async () => {
    // Create a mock response object with jest spies for header and output methods
    const res = {
      setHeader: jest.fn(),
      write: jest.fn(),
      end: jest.fn(),
    } as unknown as NextApiResponse;

    // Updated context: include required properties for GetServerSidePropsContext
    const context = {
      req: {} as any, // Dummy request object
      res,
      query: {},      // Empty query object as no parameters are needed
      resolvedUrl: '/rss.xml' // Set resolvedUrl to a valid path
    };

    // Call the server side function with the complete context object
    const result = await getServerSideProps(context);

    // Assert that the function returns empty props and sets correct headers
    expect(result).toEqual({ props: {} });
    expect(res.setHeader).toHaveBeenCalledWith('Content-Type', 'application/xml');
    expect(res.setHeader).toHaveBeenCalledWith(
      'Cache-Control',
      'public, s-maxage=1200, stale-while-revalidate=600'
    );
    expect(res.write).toHaveBeenCalled();
    expect(res.end).toHaveBeenCalled();
  });
});

================================================================================
File: ./repro.v3.test.ts
================================================================================

// repro.v3.test.ts
describe('Remark ESM V3 Repro', () => {
  it('converts markdown to HTML', async () => {
    try {
      console.debug('[V3] Importing modules: remark and remark-html...');
      
      // Dynamically import the remark module and extract its named export.
      const { remark: importRemark } = await import('remark');
      if (!importRemark) {
        throw new Error('[V3] Failed to load the named export "remark" from the remark module.');
      }
      console.debug('[V3] Remark module loaded:', importRemark);

      // Dynamically import remark-html; expect it to have a default export.
      const htmlImport = await import('remark-html');
      const transformHtml = (htmlImport as { default: any }).default;
      if (!transformHtml) {
        throw new Error('[V3] Failed to load the default export from remark-html.');
      }
      console.debug('[V3] remark-html module loaded:', transformHtml);

      console.debug('[V3] Starting markdown processing...');
      const mdSource = '# Markdown Test';
      const processedResult = await importRemark().use(transformHtml).process(mdSource);
      const htmlOutput = processedResult.toString();
      console.debug('[V3] Final HTML output:', htmlOutput);

      expect(htmlOutput).toContain('<h1>Markdown Test</h1>');
    } catch (error) {
      console.error('[V3] Error during markdown transformation:', error);
      throw error;
    }
  });
});

================================================================================
File: ./repro.test.ts
================================================================================

// repro.test.ts - NEW VERSION
describe('Remark ESM Minimal Repro (New Version)', () => {
  it('should convert markdown to HTML successfully', async () => {
    try {
      console.debug('[Test] Importing remark and remark-html...');
      
      // Dynamically import the remark module and extract its named export.
      const { remark: remarkFunction } = await import('remark');
      if (!remarkFunction) {
        throw new Error('[Test] remark function is missing from the remark module.');
      }
      console.debug('[Test] remark function imported:', remarkFunction);

      // Dynamically import remark-html and use its default export.
      const htmlModule = await import('remark-html');
      const htmlFunction = (htmlModule as { default: unknown }).default;
      if (!htmlFunction) {
        throw new Error('[Test] remark-html default export is missing.');
      }
      console.debug('[Test] remark-html imported successfully:', htmlFunction);

      console.debug('[Test] Processing markdown input...');
      const inputMarkdown = '# Hello World';
      const result = await remarkFunction().use(htmlFunction).process(inputMarkdown);
      const htmlOutput = result.toString();
      console.debug('[Test] Output HTML:', htmlOutput);

      expect(htmlOutput).toContain('<h1>Hello World</h1>');
    } catch (error) {
      console.error('[Test] Error in repro.test.ts:', error);
      throw error;
    }
  });
});

================================================================================
File: ./e2e/basic-navigation.test.ts
================================================================================

import { test, expect } from '@playwright/test';

/**
 * Basic Navigation Tests for Oslo Languages Website.
 *
 * These tests cover the navigation between Home, Courses, About, and Contact pages.
 * Explicit waits have been added to ensure pages and elements are fully loaded
 * before assertions and actions are performed.
 */
test.describe('Basic Navigation', () => {
  test('should navigate through main pages', async ({ page }) => {
    // Home page
    await page.goto('/');
    // Wait for all network requests to finish
    await page.waitForLoadState('networkidle');
    await expect(page).toHaveTitle(/Oslo Languages/);

    // Navigate to Courses
    await page.click('text=Courses');
    await page.waitForLoadState('networkidle');
    await expect(page).toHaveURL(/.*courses/);
    await expect(page.locator('h1')).toContainText('Our Language Courses');

    // Navigate to About
    await page.click('text=About');
    await page.waitForLoadState('networkidle');
    await expect(page).toHaveURL(/.*about/);
    await expect(page.locator('h1')).toContainText('About Oslo Languages');

    // Navigate to Contact
    await page.click('text=Contact');
    await page.waitForLoadState('networkidle');
    await expect(page).toHaveURL(/.*contact/);
    await expect(page.locator('h1')).toContainText('Contact Us');
  });

  test('contact form submission', async ({ page }) => {
    await page.goto('/contact');
    await page.waitForLoadState('networkidle');

    // Ensure form fields are visible before filling them
    await page.waitForSelector('input[name="name"]', { state: 'visible' });
    await page.waitForSelector('input[name="email"]', { state: 'visible' });
    await page.waitForSelector('input[name="subject"]', { state: 'visible' });
    await page.waitForSelector('textarea[name="message"]', { state: 'visible' });

    // Fill out the contact form
    await page.fill('input[name="name"]', 'Test User');
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="subject"]', 'Test Subject');
    await page.fill('textarea[name="message"]', 'Test Message');

    // Submit the form
    await page.click('button[type="submit"]');

    // Check for the success message
    await expect(page.locator('text=Thank you for your message')).toBeVisible();
  });
});

================================================================================
File: ./e2e/blog-system.test.ts
================================================================================

import { test, expect } from '@playwright/test';

/**
 * Blog System Tests for Oslo Languages Website.
 *
 * This test verifies that an admin can create and publish a blog post.
 * Explicit waits have been added to ensure the login form and new post page load fully.
 */
test.describe('Blog System', () => {
  test('admin can create and publish blog post', async ({ page }) => {
    // Login as admin
    await page.goto('/admin/login');
    await page.waitForLoadState('networkidle');
    await page.waitForSelector('input[name="email"]', { state: 'visible' });
    await page.waitForSelector('input[name="password"]', { state: 'visible' });

    // Use environment variables or fallback defaults for credentials
    const adminEmail = process.env.ADMIN_EMAIL || 'admin@example.com';
    const adminPassword = process.env.ADMIN_PASSWORD || 'password';

    await page.fill('input[name="email"]', adminEmail);
    await page.fill('input[name="password"]', adminPassword);
    await page.click('button[type="submit"]');

    // Wait for navigation after login
    await page.waitForLoadState('networkidle');

    // Create a new post
    await page.goto('/admin/posts/new');
    await page.waitForLoadState('networkidle');
    await page.waitForSelector('input[name="title"]', { state: 'visible' });

    await page.fill('input[name="title"]', 'Test Post');
    await page.fill('textarea[name="excerpt"]', 'Test excerpt');
    await page.fill('textarea[name="content"]', 'Test content');

    // Publish the post
    await page.click('text=Publish');

    // Verify the post appears on the blog page
    await page.goto('/blog');
    await page.waitForLoadState('networkidle');
    await expect(page.locator('text=Test Post')).toBeVisible();
  });
});

================================================================================
File: ./src/utils/__tests__/api-utils.test.ts
================================================================================

// src/utils/__tests__/api-utils.test.ts

import { validateRequest, ApiError, validators } from '../api-utils';

describe('API Utilities', () => {
  describe('validateRequest', () => {
    const testData = {
      name: 'Test User',
      email: 'test@example.com',
      age: 25
    };

    it('validates data correctly', () => {
      // Include all required validators: name, email, and age
      const validations = {
        name: validators.required('name'),
        email: validators.email(),
        age: validators.required('age')
      };

      const errors = validateRequest(testData, validations);
      expect(errors).toHaveLength(0);
    });

    it('returns errors for invalid data', () => {
      const validations = {
        name: validators.required('name'),
        email: validators.email(),
        age: validators.required('age')
      };

      const errors = validateRequest({ ...testData, email: 'invalid' }, validations);
      expect(errors).toHaveLength(1);
      expect(errors[0].field).toBe('email');
    });
  });

  describe('ApiError', () => {
    it('creates error with correct properties', () => {
      const error = new ApiError('Test error', 400, { details: 'test' });
      expect(error.message).toBe('Test error');
      expect(error.statusCode).toBe(400);
      expect(error.data).toEqual({ details: 'test' });
    });
  });
});

================================================================================
File: ./src/utils/__tests__/blog.test.ts
================================================================================

// src/utils/__tests__/blog.test.ts
import { createPost, filterPosts, calculateReadingTime, BlogError } from '../blog';
import { BlogPost } from '@/types/blog';


const mockPosts: BlogPost[] = [
  {
    id: '1',
    title: 'First Post',
    slug: 'first-post',
    content: 'This is the first post content.',
    excerpt: 'First post excerpt',
    author: 'John Doe',
    date: '2024-01-01',
    categories: ['Norwegian', 'Beginner'],
    tags: ['language', 'learning'],
  },
  {
    id: '2',
    title: 'Second Post',
    slug: 'second-post',
    content: 'Another test post content.',
    excerpt: 'Second post excerpt',
    author: 'Jane Smith',
    date: '2024-01-02',
    categories: ['English', 'Advanced'],
    tags: ['business', 'language'],
  },
];

describe('Blog Utilities', () => {
  describe('createPost', () => {
    it('creates a new blog post', async () => {
      const data = {
        title: 'Test Post',
        content: 'Test content',
        excerpt: 'Test excerpt'
      };

      const post = await createPost(data);
      
      expect(post).toHaveProperty('id');
      expect(post.title).toBe(data.title);
      expect(post.slug).toBe('test-post');
    });

    it('throws validation error for missing title', async () => {
      await expect(createPost({}))
        .rejects
        .toThrow(BlogError);
    });
  });

  describe('filterPosts', () => {
    const posts: BlogPost[] = [
      {
        id: '1',
        title: 'Test Post',
        slug: 'test-post',
        content: 'Test content',
        excerpt: 'Test excerpt',
        author: 'Test Author',
        date: '2024-01-01',
        status: 'published',
        categories: ['test'],
        tags: ['test']
      }
    ];

    it('filters posts by category', () => {
      const filtered = filterPosts(posts, { category: 'test' });
      expect(filtered).toHaveLength(1);
    });

    it('filters posts by search term', () => {
      const filtered = filterPosts(posts, { query: 'test' });
      expect(filtered).toHaveLength(1);
    });
  });

  describe('calculateReadingTime', () => {
    it('calculates reading time correctly', () => {
      const content = 'word '.repeat(400);
      expect(calculateReadingTime(content)).toBe('2 min read');
    });
  });
});
================================================================================
File: ./src/utils/blog.test.ts
================================================================================

// src/lib/__tests__/blog.test.ts
import fs from 'fs/promises';
import path from 'path';
import { BlogPost } from '@/types/blog'; // Import BlogPost type for proper annotations

import { 
  getPostBySlug, 
  getAllPosts, 
  getPostsByCategory, 
  getPostsByTag,
  generatePostPath 
} from './blog';

// Mock fs module
jest.mock('fs/promises');
jest.mock('path');

// Mock posts data
const mockPosts = [
  {
    slug: 'first-post',
    content: '# First Post\nThis is a test post with some content.\nIt has multiple paragraphs.\nAnd some more text.',
    data: {
      title: 'First Post',
      date: '2024-01-01',
      excerpt: 'First post excerpt',
      author: 'John Doe',
      categories: ['Norwegian', 'Beginner'],
      tags: ['language', 'learning'],
      coverImage: '/images/post1.jpg'
    }
  },
  {
    slug: 'second-post',
    content: '# Second Post\nAnother test post.\nWith different content.',
    data: {
      title: 'Second Post',
      date: '2024-01-02',
      excerpt: 'Second post excerpt',
      author: 'Jane Smith',
      categories: ['English', 'Advanced'],
      tags: ['business', 'language'],
      coverImage: '/images/post2.jpg'
    }
  },
  {
    slug: 'third-post',
    content: '# Third Post\nYet another post.\nThis one is shorter.',
    data: {
      title: 'Third Post',
      date: '2024-01-03',
      excerpt: 'Third post excerpt',
      author: 'John Doe',
      categories: ['Norwegian', 'Advanced'],
      tags: ['learning', 'culture'],
      coverImage: '/images/post3.jpg'
    }
  }
];

// Setup mock filesystem
beforeAll(() => {
  const mockFileSystem: Record<string, string> = mockPosts.reduce((acc: Record<string, string>, post) => {
    acc[`${post.slug}.md`] = `---
title: ${post.data.title}
date: ${post.data.date}
excerpt: ${post.data.excerpt}
author: ${post.data.author}
categories: ${JSON.stringify(post.data.categories)}
tags: ${JSON.stringify(post.data.tags)}
coverImage: ${post.data.coverImage}
---

${post.content}`;
    return acc;
  }, {});

  // Mock fs.readdir
  (fs.readdir as jest.Mock).mockResolvedValue(Object.keys(mockFileSystem));

  // Mock fs.readFile
  (fs.readFile as jest.Mock).mockImplementation((filePath) => {
    const fileName = path.basename(filePath);
    const content = mockFileSystem[fileName];
    if (!content) throw new Error(`File not found: ${fileName}`);
    return Promise.resolve(content);
  });

  // Mock path.join to return the file name
  (path.join as jest.Mock).mockImplementation((...args) => args[args.length - 1]);
});

describe('Blog Functions', () => {

  beforeAll(async () => {
    // Add slight delay for FS operations
    await new Promise(resolve => setTimeout(resolve, 100));
  });

  describe('Post Retrieval', () => {
    it('should retrieve a single post by slug', async () => {
      const post = await getPostBySlug('first-post');
      
      expect(post).toBeDefined();
      expect(post.title).toBe('First Post');
      expect(post.content).toContain('<h1>First Post</h1>');
      expect(post.author).toBe('John Doe');
    });

    it('should retrieve all posts sorted by date', async () => {
      const posts = await getAllPosts();
      
      expect(posts).toHaveLength(3);
      expect(posts[0].title).toBe('Third Post'); // Most recent first
      expect(posts[2].title).toBe('First Post'); // Oldest last
    });

    it('should handle non-existent post slugs', async () => {
      await expect(getPostBySlug('non-existent')).rejects.toThrow();
    });

    it('should correctly parse markdown content', async () => {
      const post = await getPostBySlug('first-post');
      
      expect(post.content).toContain('<h1>');
      expect(post.content).toContain('<p>');
      expect(post.content).not.toContain('#');
    });
  });

  describe('Category Filtering', () => {
    it('should filter posts by category', async () => {
      const norwegianPosts = await getPostsByCategory('Norwegian');
      
      expect(norwegianPosts).toHaveLength(2);
      expect(norwegianPosts.every((post: BlogPost) => 
        post.categories.includes('Norwegian')
      )).toBe(true);
    });

    it('should handle category case-insensitively', async () => {
      const norwegianPosts = await getPostsByCategory('norwegian');
      const advancedPosts = await getPostsByCategory('ADVANCED');
      
      expect(norwegianPosts).toHaveLength(2);
      expect(advancedPosts).toHaveLength(2);
    });

    it('should return empty array for non-existent category', async () => {
      const posts = await getPostsByCategory('non-existent');
      
      expect(posts).toHaveLength(0);
    });

    it('should maintain post order within category', async () => {
      const norwegianPosts = await getPostsByCategory('Norwegian');
      
      expect(new Date(norwegianPosts[0].date).getTime()).toBeGreaterThan(new Date(norwegianPosts[1].date).getTime());
    });
  });

  describe('Tag Filtering', () => {
    it('should filter posts by tag', async () => {
      const learningPosts = await getPostsByTag('learning');
      
      expect(learningPosts).toHaveLength(2);
      expect(learningPosts.every((post: BlogPost) => 
        post.tags.includes('learning')
      )).toBe(true);
    });

    it('should handle tag case-insensitively', async () => {
      const learningPosts = await getPostsByTag('LEARNING');
      const businessPosts = await getPostsByTag('business');
      
      expect(learningPosts).toHaveLength(2);
      expect(businessPosts).toHaveLength(1);
    });

    it('should return empty array for non-existent tag', async () => {
      const posts = await getPostsByTag('non-existent');
      
      expect(posts).toHaveLength(0);
    });

    it('should maintain post order within tag', async () => {
      const learningPosts = await getPostsByTag('learning');
      
      expect(new Date(learningPosts[0].date).getTime()).toBeGreaterThan(new Date(learningPosts[1].date).getTime());
    });
  });

  describe('Reading Time Calculation', () => {
    it('should calculate reading time for short posts', async () => {
      const post = await getPostBySlug('third-post');
      expect(post.readingTime).toBe('1 min read');
    });

    it('should calculate reading time for longer posts', async () => {
      // Create a longer post content
      const longContent = 'word '.repeat(1000); // 1000 words
      (fs.readFile as jest.Mock).mockResolvedValueOnce(`---
title: Long Post
date: 2024-01-04
excerpt: Long post excerpt
author: John Doe
categories: ["Test"]
tags: ["test"]
coverImage: /images/long.jpg
---

${longContent}`);

      const post = await getPostBySlug('long-post');
      expect(post.readingTime).toBe('5 min read');
    });

    it('should round reading time up to nearest minute', async () => {
      // Create a post with 250 words (should round up to 2 minutes)
      const mediumContent = 'word '.repeat(250);
      (fs.readFile as jest.Mock).mockResolvedValueOnce(`---
title: Medium Post
date: 2024-01-04
excerpt: Medium post excerpt
author: John Doe
categories: ["Test"]
tags: ["test"]
coverImage: /images/medium.jpg
---

${mediumContent}`);

      const post = await getPostBySlug('medium-post');
      expect(post.readingTime).toBe('2 min read');
    });

    it('should handle posts with code blocks', async () => {
      const postWithCode = `---
title: Code Post
date: 2024-01-04
excerpt: Code post excerpt
author: John Doe
categories: ["Test"]
tags: ["test"]
coverImage: /images/code.jpg
---

Here's some regular text.

\`\`\`javascript
function example() {
  return 'Hello World';
}
\`\`\`

More text here.`;

      (fs.readFile as jest.Mock).mockResolvedValueOnce(postWithCode);

      const post = await getPostBySlug('code-post');
      expect(post.readingTime).toBeDefined();
      expect(typeof post.readingTime).toBe('string');
    });
  });

  describe('Path Generation', () => {
    it('should generate correct post paths', () => {
      expect(generatePostPath('test-post')).toBe('/blog/test-post');
    });

    it('should handle slugs with special characters', () => {
      expect(generatePostPath('test-post-123!')).toBe('/blog/test-post-123!');
    });
  });
});
================================================================================
File: ./src/components/layout/header/__tests__/Header.test.tsx
================================================================================

// src/components/layout/header/__tests__/Header.test.tsx

import { render, screen, fireEvent } from '@testing-library/react';
import Header from '../Header';

// Mock usePathname
jest.mock('next/navigation', () => ({
  usePathname: () => '/',
}));

describe('Header', () => {
  it('renders logo and navigation links', () => {
    render(<Header />);
    
    // Check logo specifically
    expect(screen.getByRole('link', { name: /oslo languages/i })).toBeInTheDocument();
    
    // Check desktop navigation links only
    const desktopNav = screen.getByRole('navigation').querySelector('.md\\:flex');
    const desktopLinks = desktopNav?.querySelectorAll('a');
    expect(desktopLinks).toBeDefined();
    expect(desktopLinks?.length).toBe(4); // Home, Courses, About, Contact
  });

  it('toggles mobile menu', () => {
    render(<Header />);
    
    const mobileMenu = screen.getByRole('menu');
    const menuButton = screen.getByRole('button', { name: /open main menu/i });
    
    // Initially hidden
    expect(mobileMenu).toHaveClass('hidden');
    
    // Show menu
    fireEvent.click(menuButton);
    expect(mobileMenu).not.toHaveClass('hidden');
    
    // Hide menu
    fireEvent.click(menuButton);
    expect(mobileMenu).toHaveClass('hidden');
  });

  it('shows correct active link styling', () => {
    render(<Header />);
    
    // Find home link in desktop navigation
    const desktopNav = screen.getByRole('navigation').querySelector('.md\\:flex');
    const homeLink = desktopNav?.querySelector('a[href="/"]');
    
    // Since path is '/' (from mock), home should have active styling
    expect(homeLink).toHaveClass('bg-blue-600', 'text-white');
  });
});
================================================================================
File: ./src/components/blog/__tests__/BlogCategories.test.tsx
================================================================================

// src/components/blog/__tests__/BlogCategories.test.tsx
import { render, screen } from '@testing-library/react';
import BlogCategories from '../BlogCategories';

const mockCategories = [
  { name: 'Norwegian', count: 5, slug: 'norwegian' },
  { name: 'English', count: 3, slug: 'english' },
  { name: 'Learning Tips', count: 2, slug: 'learning-tips' },
];

describe('BlogCategories', () => {
  it('renders all categories with correct counts', () => {
    render(<BlogCategories categories={mockCategories} />);
    
    mockCategories.forEach(category => {
      expect(screen.getByText(category.name)).toBeInTheDocument();
      expect(screen.getByText(category.count.toString())).toBeInTheDocument();
    });
  });

  it('highlights active category', () => {
    render(
      <BlogCategories
        categories={mockCategories}
        activeCategory="norwegian"
      />
    );
    
    const activeLink = screen.getByText('Norwegian').closest('a');
    expect(activeLink).toHaveAttribute('aria-current', 'page');
    expect(activeLink).toHaveClass('bg-blue-600');
  });

  it('renders with custom className', () => {
    render(
      <BlogCategories
        categories={mockCategories}
        className="test-class"
      />
    );
    
    const nav = screen.getByRole('navigation');
    expect(nav).toHaveClass('test-class');
  });

  it('renders navigation landmark with correct label', () => {
    render(<BlogCategories categories={mockCategories} />);
    
    expect(screen.getByRole('navigation'))
      .toHaveAttribute('aria-label', 'Blog categories');
  });
});
================================================================================
File: ./src/components/blog/__tests__/BlogPost.test.tsx
================================================================================

// src/components/blog/__tests__/BlogPost.test.tsx
import { render, screen, waitFor, within, act } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import BlogPost from '../BlogPost';
import { BlogPost as BlogPostType } from '@/utils/blog';
import * as React from 'react';

jest.mock('next/head', () => {
  const MockHead = ({ children }: { children: React.ReactNode }): null => {
    React.useEffect(() => {
      // Remove previous head elements added by MockHead
      const existing = document.querySelectorAll('[data-mock-head]');
      existing.forEach((el) => el.parentNode?.removeChild(el));
      React.Children.forEach(children, (child: React.ReactNode) => {
        if (React.isValidElement(child) && child.props) {
          const el = document.createElement(child.type as string);
          Object.entries(child.props).forEach(([key, value]) => {
            if (key !== 'children') {
              el.setAttribute(key, value as string);
            }
          });
          if (child.props.children) {
            el.textContent = child.props.children;
          }
          el.setAttribute('data-mock-head', 'true');
          document.head.appendChild(el);
        }
      });
    }, [children]);
    return null;
  };
  MockHead.displayName = 'MockHead';
  return { __esModule: true, default: MockHead };
});

jest.mock('lucide-react', () => {
  const MockTwitter = (props: any) => <span {...props}>TwitterIcon</span>;
  MockTwitter.displayName = 'MockTwitter';
  const MockLinkedin = (props: any) => <span {...props}>LinkedInIcon</span>;
  MockLinkedin.displayName = 'MockLinkedin';
  const MockMail = (props: any) => <span {...props}>MailIcon</span>;
  MockMail.displayName = 'MockMail';
  const MockChevronDown = (props: any) => <span {...props}>ChevronDown</span>;
  MockChevronDown.displayName = 'MockChevronDown';
  const MockChevronUp = (props: any) => <span {...props}>ChevronUp</span>;
  MockChevronUp.displayName = 'MockChevronUp';
  return {
    Twitter: MockTwitter,
    Linkedin: MockLinkedin,
    Mail: MockMail,
    ChevronDown: MockChevronDown,
    ChevronUp: MockChevronUp,
  };
});

// Mock Next/Image
jest.mock('next/image', () => ({
  __esModule: true,
  default: (props: any) => {
    const { fill, priority, blurDataURL, ...rest } = props;
    return <img {...rest} />;
  }
}));



// Mock useRouter
jest.mock('next/navigation', () => ({
  useRouter: jest.fn()
}));

jest.mock('react-intersection-observer', () => ({
  useInView: () => ({ ref: jest.fn(), inView: true })
}));

describe('BlogPost', () => {
  const mockPost: BlogPostType = {
    id: 'test-post-id',
    slug: 'test-post',
    title: 'Test Blog Post',
    date: '2024-01-20',
    excerpt: 'This is a test blog post',
    author: 'John Doe',
    content:
      '<h1>Test Blog Post</h1><p>This is test content.</p><pre><code>const test = "code";</code></pre>',
    categories: ['Test', 'Example'],
    tags: ['test', 'example'],
    coverImage: '/images/test.jpg',
    readingTime: '3 min read'
  };

  it('should have proper ARIA labels', () => {
    render(<BlogPost post={mockPost} />);
    expect(screen.getByRole('article')).toHaveAttribute('aria-labelledby');
    expect(screen.getByRole('region', { name: 'Share options' }))
      .toHaveAttribute('aria-label', 'Share options');
  });



  it('should update metadata when post changes', () => {
    const { rerender } = render(<BlogPost post={mockPost} />);
    const updatedPost = { ...mockPost, title: 'Updated Title', excerpt: 'Updated excerpt' };
    rerender(<BlogPost post={updatedPost} />);
    const metaTags = document.head.querySelectorAll('meta');
    expect(metaTags).not.toHaveLength(0);
  });

  describe('Content Rendering', () => {
    it('should render the post title and metadata', () => {
      render(<BlogPost post={mockPost} />);
      const headerTitle = screen.getByTestId('blog-post-title');
      expect(headerTitle).toBeInTheDocument();
      expect(headerTitle).toHaveAttribute('id', 'blog-post-title');
      expect(screen.getByText(mockPost.author)).toBeInTheDocument();
      expect(screen.getByText('January 19, 2024')).toBeInTheDocument();
      expect(screen.getByText('3 min read')).toBeInTheDocument();
    });

    it('should render categories as clickable links', () => {
      render(<BlogPost post={mockPost} />);
      const categoriesNav = screen.getByLabelText('Post categories');
      mockPost.categories.forEach((category: string) => {
        const categoryLink = within(categoriesNav).getByRole('link', { name: category });
        expect(categoryLink).toBeInTheDocument();
        expect(categoryLink).toHaveAttribute('href', expect.stringContaining('/blog/category/'));
      });
    });

    it('should render tags with proper formatting', () => {
      render(<BlogPost post={mockPost} />);
      mockPost.tags.forEach((tag: string) => {
        const tagLink = screen.getByRole('link', { name: new RegExp(`#${tag}`, 'i') });
        expect(tagLink).toBeInTheDocument();
        expect(tagLink).toHaveAttribute('href', expect.stringContaining('/blog/tag/'));
      });
    });

    it('should handle posts without optional fields', () => {
      const minimalPost: BlogPostType = {
        ...mockPost,
        categories: [],
        tags: [],
        coverImage: '/images/default.jpg'
      };
      render(<BlogPost post={minimalPost} />);
      expect(screen.queryByRole('img')).toBeInTheDocument();
      expect(screen.queryByTestId('categories')).not.toBeInTheDocument();
      expect(screen.queryByTestId('tags')).not.toBeInTheDocument();
    });
  });

  describe('Rich Text Handling', () => {
    const richTextPost: BlogPostType = {
      ...mockPost,
      content: `
        <h1>Main Title</h1>
        <p>Regular paragraph with <strong>bold</strong> and <em>italic</em> text.</p>
        <h2>Subheading</h2>
        <ul>
          <li>List item 1</li>
          <li>List item 2</li>
        </ul>
        <pre><code class="language-javascript">
        const example = "code block";
        console.log(example);
        </code></pre>
        <blockquote>
          <p>This is a quote</p>
        </blockquote>
      `
    };

    it('should render HTML elements with proper styling', () => {
      render(<BlogPost post={richTextPost} />);
      expect(screen.getByText('Main Title')).toHaveClass('prose-h1');
      expect(screen.getByRole('heading', { level: 2, name: 'Subheading' })).toHaveClass('prose-h2');
      expect(screen.getByText(/Regular paragraph/)).toHaveClass('prose-p');
    });

    it('should render code blocks with syntax highlighting', () => {
      render(<BlogPost post={richTextPost} />);
      const codeBlock = screen.getByText(/const example/);
      expect(codeBlock).toBeInTheDocument();
      expect(codeBlock.closest('pre')).toHaveClass('language-javascript');
    });

    it('should handle markdown tables correctly', () => {
      const postWithTable: BlogPostType = {
        ...mockPost,
        content: `
          <table>
            <thead>
              <tr><th>Header 1</th><th>Header 2</th></tr>
            </thead>
            <tbody>
              <tr><td>Cell 1</td><td>Cell 2</td></tr>
            </tbody>
          </table>
        `
      };
      render(<BlogPost post={postWithTable} />);
      expect(screen.getByRole('table')).toBeInTheDocument();
      expect(screen.getAllByRole('row')).toHaveLength(2);
    });

    it('should sanitize potentially unsafe HTML', () => {
      const postWithUnsafeContent: BlogPostType = {
        ...mockPost,
        content: `
          <p>Safe content</p>
          <script>alert('unsafe');</script>
          <img src="x" onerror="alert('unsafe')">
        `
      };
      render(<BlogPost post={postWithUnsafeContent} />);
      expect(screen.getByText('Safe content')).toBeInTheDocument();
      const richContent = screen.getByTestId('rich-content');
      expect(within(richContent).queryByRole('script')).not.toBeInTheDocument();
      const img = document.querySelector('img');
      expect(img?.getAttribute('onerror')).toBeNull();
    });
  });


  describe('SEO Metadata', () => {
    it('should render OG metadata tags', () => {
      render(<BlogPost post={mockPost} />);
      const ogTitle = document.querySelector('meta[property="og:title"]');
      expect(ogTitle).toHaveAttribute('content', mockPost.title);
      const ogDescription = document.querySelector('meta[property="og:description"]');
      expect(ogDescription).toHaveAttribute('content', mockPost.excerpt);
      const ogImage = document.querySelector('meta[property="og:image"]');
      expect(ogImage).toHaveAttribute('content', mockPost.coverImage);
    });

    it('should render schema.org metadata', () => {
      render(<BlogPost post={mockPost} />);
      const script = document.querySelector('script[type="application/ld+json"]');
      expect(script).toBeInTheDocument();
      const schema = JSON.parse(script!.innerHTML);
      expect(schema['@type']).toBe('BlogPosting');
      expect(schema.headline).toBe(mockPost.title);
      expect(schema.author.name).toBe(mockPost.author);
    });

    it('should update metadata when post changes', () => {
      const { rerender } = render(<BlogPost post={mockPost} />);
      const updatedPost: BlogPostType = { ...mockPost, title: 'Updated Title', excerpt: 'Updated excerpt' };
      rerender(<BlogPost post={updatedPost} />);
      const ogTitle = document.querySelector('meta[property="og:title"]');
      expect(ogTitle).toHaveAttribute('content', 'Updated Title');
      const ogDescription = document.querySelector('meta[property="og:description"]');
      expect(ogDescription).toHaveAttribute('content', 'Updated excerpt');
    });

    it('should have proper canonical URL', () => {
      render(<BlogPost post={mockPost} />);
      const canonical = document.querySelector('link[rel="canonical"]');
      expect(canonical).toHaveAttribute('href', expect.stringContaining(mockPost.slug));
    });
  });

  describe('Accessibility', () => {
    it('should have proper heading hierarchy', () => {
      render(<BlogPost post={mockPost} />);
      const headings = screen.getAllByRole('heading');
      const levels = headings.map((h) => parseInt(h.tagName.replace('H', '')));
      expect(Math.min(...levels)).toBe(1);
      expect(levels).toEqual(levels.slice().sort((a, b) => a - b));
    });

    it('should have proper ARIA labels', () => {
      render(<BlogPost post={mockPost} />);
      expect(screen.getByRole('article')).toHaveAttribute('aria-labelledby');
      expect(screen.getByRole('region', { name: 'Share options' }))
        .toHaveAttribute('aria-label', 'Share options');
    });


  });
});

================================================================================
File: ./src/components/blog/__tests__/BlogSearch.test.tsx
================================================================================

// src/components/blog/__tests__/BlogSearch.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import BlogSearch from '../BlogSearch';

describe('BlogSearch Component', () => {
  const mockOnSearchChange = jest.fn();
  const mockOnCategoryChange = jest.fn();
  const mockOnTagChange = jest.fn();
  const mockOnSortChange = jest.fn();

  beforeEach(() => {
    render(
      <BlogSearch
        search=""
        category=""
        tag=""
        sortBy="date-desc"
        onSearchChange={mockOnSearchChange}
        onCategoryChange={mockOnCategoryChange}
        onTagChange={mockOnTagChange}
        onSortChange={mockOnSortChange}
      />
    );
  });

  it('renders input and select elements', () => {
    expect(screen.getByPlaceholderText('Search posts...')).toBeInTheDocument();
    expect(screen.getByDisplayValue('date-desc')).toBeInTheDocument();
  });

  it('calls onSearchChange when typing in the search input', () => {
    const input = screen.getByPlaceholderText('Search posts...');
    fireEvent.change(input, { target: { value: 'react' } });
    expect(mockOnSearchChange).toHaveBeenCalledWith('react');
  });

  it('calls onCategoryChange when changing the category', () => {
    const select = screen.getByRole('combobox', { name: '' });
    fireEvent.change(select, { target: { value: 'tech' } });
    expect(mockOnCategoryChange).toHaveBeenCalledWith('tech');
  });

  it('calls onTagChange when changing the tag', () => {
    // Select the second select (tag selector)
    const selects = screen.getAllByRole('combobox');
    fireEvent.change(selects[1], { target: { value: 'react' } });
    expect(mockOnTagChange).toHaveBeenCalledWith('react');
  });

  it('calls onSortChange when changing the sort order', () => {
    // Select the third select (sort selector)
    const selects = screen.getAllByRole('combobox');
    fireEvent.change(selects[2], { target: { value: 'title-asc' } });
    expect(mockOnSortChange).toHaveBeenCalledWith('title-asc');
  });
});

================================================================================
File: ./src/components/blog/__tests__/BlogList.test.tsx
================================================================================

// src/components/blog/__tests__/BlogList.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import BlogList from '../BlogList';
import { BlogPost } from '@/types/blog';

// Mock the OptimizedImage component
jest.mock('@/components/OptimizedImage', () => {
  return function MockOptimizedImage({ alt }: { alt: string }) {
    return <img alt={alt} />;
  };
});

const mockPosts: BlogPost[] = [
  {
    id: '1',
    title: 'First Post',
    slug: 'first-post',
    content: 'Content of first post',
    excerpt: 'First post excerpt',
    author: 'John Doe',
    date: '2024-01-01',
    categories: ['Norwegian', 'Beginner'],
    tags: ['language', 'learning'],
    coverImage: '/images/post1.jpg'
  },
  {
    id: '2',
    title: 'Second Post',
    slug: 'second-post',
    content: 'Content of second post',
    excerpt: 'Second post excerpt',
    author: 'Jane Smith',
    date: '2024-01-02',
    categories: ['English', 'Advanced'],
    tags: ['business', 'language'],
    coverImage: '/images/post2.jpg'
  }
];

describe('Consolidated BlogList', () => {
  it('handles category filtering from consolidated API', async () => {
    const mockPostsForFilter: BlogPost[] = [
      {
        id: '1',
        slug: 'test-post',
        title: 'Test Post',
        content: 'Dummy content for test post',
        excerpt: 'Test post excerpt',
        author: 'Tester',
        date: '2024-01-01',
        categories: ['test'],
        tags: ['example'],
        coverImage: '/images/test.jpg'
      },
      {
        id: '2',
        slug: 'other-post',
        title: 'Other Post',
        content: 'Dummy content for other post',
        excerpt: 'Other post excerpt',
        author: 'Tester',
        date: '2024-01-02',
        categories: ['other'],
        tags: ['example'],
        coverImage: '/images/other.jpg'
      }
    ];
    
    render(<BlogList posts={mockPostsForFilter} />);
    
    const categoryButton = screen.getByText('test');
    fireEvent.click(categoryButton);
    
    await waitFor(() => {
      expect(screen.getByText('Test Post')).toBeInTheDocument();
      expect(screen.queryByText('Other Post')).not.toBeInTheDocument();
    });
  });
});

describe('BlogList Component', () => {
  it('renders a list of blog posts', () => {
    render(<BlogList posts={mockPosts} />);
    
    expect(screen.getByText('First Post')).toBeInTheDocument();
    expect(screen.getByText('Second Post')).toBeInTheDocument();
  });

  it('displays "No posts found" when there are no posts', () => {
    render(<BlogList posts={[]} />);
    
    expect(screen.getByText('No posts found')).toBeInTheDocument();
  });

  it('displays categories and allows filtering by category', () => {
    render(<BlogList posts={mockPosts} />);
    
    const categoryButton = screen.getByText('Norwegian');
    fireEvent.click(categoryButton);
    
    // After filtering, only the first post should be visible
    expect(screen.getByText('First Post')).toBeInTheDocument();
    expect(screen.queryByText('Second Post')).not.toBeInTheDocument();
  });

  it('displays tags and allows filtering by tag', () => {
    render(<BlogList posts={mockPosts} />);
    
    const tagButton = screen.getByText('#business');
    fireEvent.click(tagButton);
    
    // After filtering, only the second post should be visible
    expect(screen.queryByText('First Post')).not.toBeInTheDocument();
    expect(screen.getByText('Second Post')).toBeInTheDocument();
  });

  it('displays pagination controls when there are more posts than the limit', () => {
    render(
      <BlogList 
        posts={mockPosts} 
        pagination={{ page: 1, limit: 1 }}
      />
    );
    
    expect(screen.getByText('Page 1 of 2')).toBeInTheDocument();
    expect(screen.getByText('Next')).toBeInTheDocument();
  });

  it('disables pagination buttons appropriately', () => {
    render(
      <BlogList 
        posts={mockPosts} 
        pagination={{ page: 1, limit: 1 }}
      />
    );
    
    const previousButton = screen.getByText('Previous');
    const nextButton = screen.getByText('Next');
    
    expect(previousButton).toBeDisabled();
    expect(nextButton).not.toBeDisabled();
  });

  it('formats dates correctly', () => {
    render(<BlogList posts={mockPosts} />);
    
    expect(screen.getByText('January 1, 2024')).toBeInTheDocument();
    expect(screen.getByText('January 2, 2024')).toBeInTheDocument();
  });

  it('renders post excerpts', () => {
    render(<BlogList posts={mockPosts} />);
    
    expect(screen.getByText('First post excerpt')).toBeInTheDocument();
    expect(screen.getByText('Second post excerpt')).toBeInTheDocument();
  });

  it('links to individual post pages', () => {
    render(<BlogList posts={mockPosts} />);
    
    const firstPostLink = screen.getByRole('link', { name: 'First Post' });
    expect(firstPostLink).toHaveAttribute('href', '/blog/first-post');
  });

  it('applies custom className', () => {
    const { container } = render(
      <BlogList posts={mockPosts} className="custom-class" />
    );
    
    expect(container.firstChild).toHaveClass('custom-class');
  });
});

================================================================================
File: ./src/components/courses/__tests__/CourseRegistration.test.tsx
================================================================================

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import CourseRegistration from '../CourseRegistration';
import userEvent from '@testing-library/user-event';
import { act } from '@testing-library/react';

const mockProps = {
  courseId: 'course1',
  sessionId: 'session1',
  courseName: 'Norwegian for Beginners',
  sessionDate: 'March 1, 2025',
  onSubmit: jest.fn().mockResolvedValue(undefined)
};

describe('CourseRegistration', () => {
  beforeEach(() => {
    jest.resetAllMocks();
  });

  it('renders the registration form', () => {
    render(<CourseRegistration {...mockProps} />);
    
    expect(screen.getByText('Norwegian for Beginners')).toBeInTheDocument();
    expect(screen.getByText(/March 1, 2025/)).toBeInTheDocument();
    expect(screen.getByLabelText(/First Name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Email/i)).toBeInTheDocument();
  });

  it('shows validation errors for required fields', async () => {
    render(<CourseRegistration {...mockProps} />);
    
    await act(async () => {
      const submitButton = screen.getByRole('button', { name: /Complete Registration/i });
      await userEvent.click(submitButton);
    });

    await waitFor(() => {
      expect(screen.getByText(/First name is required/i)).toBeInTheDocument();
      expect(screen.getByText(/Email is required/i)).toBeInTheDocument();
    });
  });

  it('validates email format', async () => {
    render(<CourseRegistration {...mockProps} />);
  
    const emailInput = screen.getByLabelText(/email/i);
    
    await act(async () => {
      await userEvent.type(emailInput, 'invalid-email');
      fireEvent.blur(emailInput); // Trigger blur event to validate email format
    });

    await waitFor(() => {
      expect(screen.getByText(/Invalid email address/i)).toBeInTheDocument();
    });
  });

  it('submits form with valid data', async () => {
    render(<CourseRegistration {...mockProps} />);
    
    await act(async () => {
      await userEvent.type(screen.getByLabelText(/First Name/i), 'John');
      await userEvent.type(screen.getByLabelText(/Last Name/i), 'Doe');
      await userEvent.type(screen.getByLabelText(/Email/i), 'john@example.com');
      await userEvent.type(screen.getByLabelText(/Phone Number/i), '12345678');
      fireEvent.blur(screen.getByLabelText(/Email/i)); // Ensure validation triggers
    });

    await act(async () => {
      await userEvent.click(screen.getByRole('button', { name: /Complete Registration/i }));
    });

    await waitFor(() => {
      expect(mockProps.onSubmit).toHaveBeenCalledWith({
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
        phone: '12345678',
        languageLevel: '',
        specialRequirements: ''
      });
    });
  });

  it('shows success message after successful submission', async () => {
    render(<CourseRegistration {...mockProps} />);
    
    await act(async () => {
      fireEvent.change(screen.getByLabelText(/First Name/i), { target: { value: 'John' } });
      fireEvent.change(screen.getByLabelText(/Last Name/i), { target: { value: 'Doe' } });
      fireEvent.change(screen.getByLabelText(/Email/i), { target: { value: 'john@example.com' } });
      fireEvent.change(screen.getByLabelText(/Phone Number/i), { target: { value: '12345678' } });
    });

    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: /Complete Registration/i }));
    });

    await waitFor(() => {
      expect(screen.getByText(/Registration Successful/i)).toBeInTheDocument();
    });
  });

  it('shows error message when submission fails', async () => {
    const failedSubmit = jest.fn().mockRejectedValue(new Error('Registration failed'));
    render(<CourseRegistration {...mockProps} onSubmit={failedSubmit} />);
    
    await act(async () => {
      fireEvent.change(screen.getByLabelText(/First Name/i), { target: { value: 'John' } });
      fireEvent.change(screen.getByLabelText(/Last Name/i), { target: { value: 'Doe' } });
      fireEvent.change(screen.getByLabelText(/Email/i), { target: { value: 'john@example.com' } });
      fireEvent.change(screen.getByLabelText(/Phone Number/i), { target: { value: '12345678' } });
    });

    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: /Complete Registration/i }));
    });

    await waitFor(() => {
      expect(screen.getByText(/Registration failed/i)).toBeInTheDocument();
    });
  });

  it('displays different text for waitlist registration', () => {
    render(<CourseRegistration {...mockProps} isWaitlist={true} />);
    
    expect(screen.getByRole('button')).toHaveTextContent('Join Waitlist');
  });

  it('shows correct success message for waitlist registration', async () => {
    render(<CourseRegistration {...mockProps} isWaitlist={true} />);
    
    await act(async () => {
      fireEvent.change(screen.getByLabelText(/First Name/i), { target: { value: 'John' } });
      fireEvent.change(screen.getByLabelText(/Last Name/i), { target: { value: 'Doe' } });
      fireEvent.change(screen.getByLabelText(/Email/i), { target: { value: 'john@example.com' } });
      fireEvent.change(screen.getByLabelText(/Phone Number/i), { target: { value: '12345678' } });
    });

    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: /Join Waitlist/i }));
    });

    await waitFor(() => {
      expect(screen.getByText(/Added to Waitlist/i)).toBeInTheDocument();
      expect(screen.getByText(/We'll contact you when a spot becomes available./i)).toBeInTheDocument();
    });
  });
});

================================================================================
File: ./src/components/courses/__tests__/CourseCalendar.test.tsx
================================================================================

// src/components/courses/__tests__/CourseCalendar.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import CourseCalendar from '../CourseCalendar';

const mockSessions = [
  {
    id: '1',
    courseId: 'course1',
    startDate: '2025-03-01T00:00:00Z',
    endDate: '2025-05-01T00:00:00Z',
    availableSeats: 5,
    schedule: 'Mon & Wed 18:00-20:00'
  },
  {
    id: '2',
    courseId: 'course1',
    startDate: '2025-04-01T00:00:00Z',
    endDate: '2025-06-01T00:00:00Z',
    availableSeats: 0,
    schedule: 'Tue & Thu 18:00-20:00'
  }
];

describe('CourseCalendar', () => {
  it('renders all sessions sorted by date', () => {
    render(<CourseCalendar sessions={mockSessions} />);
    
    const dates = screen.getAllByText(/202\d/);
    expect(dates).toHaveLength(2);
    expect(dates[0]).toHaveTextContent('March 1, 2025 - May 1, 2025');
  });

  it('shows correct availability status', () => {
    render(<CourseCalendar sessions={mockSessions} />);
    
    expect(screen.getByText('5 seats available')).toBeInTheDocument();
    expect(screen.getByText('Waitlist only')).toBeInTheDocument();
  });

  it('calls onSessionSelect when session is selected', () => {
    const onSessionSelect = jest.fn();
    render(<CourseCalendar sessions={mockSessions} onSessionSelect={onSessionSelect} />);
    
    const selectButtons = screen.getAllByRole('button');
    fireEvent.click(selectButtons[0]);
    
    expect(onSessionSelect).toHaveBeenCalledWith(mockSessions[0]);
  });

  it('shows empty state when no sessions are available', () => {
    render(<CourseCalendar sessions={[]} />);
    
    expect(screen.getByText('No upcoming sessions scheduled')).toBeInTheDocument();
  });

  it('displays correct button text based on availability', () => {
    render(<CourseCalendar sessions={mockSessions} />);
    
    const buttons = screen.getAllByRole('button');
    expect(buttons[0]).toHaveTextContent('Select Date');
    expect(buttons[1]).toHaveTextContent('Join Waitlist');
  });

  it('handles undefined onSessionSelect prop', () => {
    render(<CourseCalendar sessions={mockSessions} />);
    
    const selectButton = screen.getAllByRole('button')[0];
    expect(() => fireEvent.click(selectButton)).not.toThrow();
  });

  it('applies correct styles based on availability', () => {
    render(<CourseCalendar sessions={mockSessions} />);
    
    const availableStatus = screen.getByText('5 seats available');
    const waitlistStatus = screen.getByText('Waitlist only');
    
    expect(availableStatus).toHaveClass('bg-green-100', 'text-green-800');
    expect(waitlistStatus).toHaveClass('bg-red-100', 'text-red-800');
  });
});
================================================================================
File: ./src/components/__tests__/OptimizedImage.test.tsx
================================================================================

// src/components/__tests__/OptimizedImage.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { useInView } from 'react-intersection-observer';
import OptimizedImage from '../OptimizedImage';
import Image from 'next/image';


 jest.mock('next/image', () => {
     const MockNextImage = jest.fn((props) => {
       const { blurDataURL, ...rest } = props;
       return <img {...rest} />;
     });
     return {
       __esModule: true,
       default: MockNextImage
     };
   });

// Mock react-intersection-observer as before.
jest.mock('react-intersection-observer', () => ({
  useInView: jest.fn()
}));

describe('OptimizedImage', () => {
  const mockProps = {
    src: '/test-image.jpg',
    alt: 'Test image',
    width: 800,
    height: 600
  };

  let inViewCallback: (inView: boolean) => void;

  beforeEach(() => {
    // Reset mocks
    (Image as unknown as jest.Mock).mockClear();
    (useInView as jest.Mock).mockReset();

    // Default useInView implementation
    (useInView as jest.Mock).mockImplementation(() => ({
      ref: jest.fn(),
      inView: true
    }));
  });

  describe('Image Optimization', () => {
    it('should pass correct optimization props to next/image', () => {
      render(<OptimizedImage {...mockProps} />);

      expect(Image).toHaveBeenCalledWith(
        expect.objectContaining({
          quality: expect.any(Number),
          sizes: expect.any(String)
        }),
        expect.any(Object)
      );
    });

    it('should handle responsive sizing correctly', () => {
      render(
        <OptimizedImage
          {...mockProps}
          sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
        />
      );

      expect(Image).toHaveBeenCalledWith(
        expect.objectContaining({
          sizes: "(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
        }),
        expect.any(Object)
      );
    });

    it('should respect aspect ratio constraints', () => {
      render(<OptimizedImage {...mockProps} aspectRatio={16/9} />);

      const container = screen.getByTestId('image-container');
      expect(container).toHaveStyle({
        paddingTop: '56.25%' // 9/16 * 100
      });
    });

    it('should handle different image formats', () => {
      render(
        <OptimizedImage
          {...mockProps}
          src="/test.webp"
        />
      );

      expect(Image).toHaveBeenCalledWith(
        expect.objectContaining({
          src: '/test.webp'
        }),
        expect.any(Object)
      );
    });
  });

  describe('Lazy Loading', () => {
    it('should not render image when out of view', () => {
      (useInView as jest.Mock).mockImplementation(() => ({
        ref: jest.fn(),
        inView: false
      }));

      render(<OptimizedImage {...mockProps} />);
      expect(Image).not.toHaveBeenCalled();
    });

    it('should render image when it comes into view', () => {
      (useInView as jest.Mock).mockImplementation(() => ({
        ref: jest.fn(),
        inView: false,
        onChange: (callback: (inView: boolean) => void) => {
          inViewCallback = callback;
        }
      }));

      render(<OptimizedImage {...mockProps} />);
      expect(Image).not.toHaveBeenCalled();

      // Simulate image coming into view
      if (inViewCallback) {
        inViewCallback(true);
        expect(Image).toHaveBeenCalled();
      }
    });

    it('should respect custom lazyBoundary', () => {
      render(<OptimizedImage {...mockProps} lazyBoundary="300px" />);

      expect(useInView).toHaveBeenCalledWith(
        expect.objectContaining({
          rootMargin: '300px'
        })
      );
    });


  });

  describe('Placeholder Handling', () => {
    it('should show loading skeleton initially', () => {
      render(<OptimizedImage {...mockProps} />);
      
      const skeleton = screen.getByTestId('image-skeleton');
      expect(skeleton).toHaveClass('animate-pulse');
    });

    it('should handle blur placeholder', () => {
      render(
        <OptimizedImage
          {...mockProps}
          lowQualityPlaceholder="/test-image-small.jpg"
        />
      );

      expect(Image).toHaveBeenCalledWith(
        expect.objectContaining({
          placeholder: 'blur',
          blurDataURL: '/test-image-small.jpg'
        }),
        expect.any(Object)
      );
    });

    it('should remove loading state after image loads', async () => {
      render(<OptimizedImage {...mockProps} />);
      
      const image = screen.getByTestId('optimized-image');
      fireEvent.load(image);

      await waitFor(() => {
        const skeleton = screen.queryByTestId('image-skeleton');
        expect(skeleton).not.toBeInTheDocument();
      });
    });

    it('should handle custom background colors', () => {
      render(<OptimizedImage {...mockProps} background="bg-blue-100" />);
      
      const container = screen.getByTestId('image-container');
      expect(container).toHaveClass('bg-blue-100');
    });
  });

  describe('Error States', () => {
    it('should show fallback image on error', async () => {
      render(
        <OptimizedImage
          {...mockProps}
          src="/non-existent.jpg"
          fallbackSrc="/fallback.jpg"
        />
      );

      const image = screen.getByTestId('optimized-image');
      fireEvent.error(image);

      await waitFor(() => {
        expect(Image).toHaveBeenLastCalledWith(
          expect.objectContaining({
            src: '/fallback.jpg'
          }),
          expect.any(Object)
        );
      });
    });

    it('should handle missing fallback image', async () => {
      render(<OptimizedImage {...mockProps} src="/non-existent.jpg" />);

      const image = screen.getByTestId('optimized-image');
      fireEvent.error(image);

      await waitFor(() => {
        expect(Image).toHaveBeenLastCalledWith(
          expect.objectContaining({
            src: '/images/placeholder.jpg' // Default fallback
          }),
          expect.any(Object)
        );
      });
    });

    it('should maintain aspect ratio with fallback image', async () => {
      render(
        <OptimizedImage
          {...mockProps}
          src="/non-existent.jpg"
          fallbackSrc="/fallback.jpg"
          aspectRatio={1}
        />
      );

      const image = screen.getByTestId('optimized-image');
      fireEvent.error(image);

      const container = screen.getByTestId('image-container');
      expect(container).toHaveStyle({ paddingTop: '100%' });
    });

    it('should handle subsequent source changes after error', async () => {
      const { rerender } = render(
        <OptimizedImage {...mockProps} src="/non-existent.jpg" />
      );

      const image = screen.getByTestId('optimized-image');
      fireEvent.error(image);

      rerender(<OptimizedImage {...mockProps} src="/new-image.jpg" />);

      await waitFor(() => {
        expect(Image).toHaveBeenLastCalledWith(
          expect.objectContaining({
            src: '/new-image.jpg'
          }),
          expect.any(Object)
        );
      });
    });
  });

  describe('Accessibility', () => {
    it('should have appropriate alt text', () => {
      render(<OptimizedImage {...mockProps} />);

      expect(Image).toHaveBeenCalledWith(
        expect.objectContaining({
          alt: 'Test image'
        }),
        expect.any(Object)
      );
    });

    it('should mark decorative images appropriately', () => {
      render(<OptimizedImage {...mockProps} alt="" aria-hidden="true" role="presentation" />);

      expect(Image).toHaveBeenCalledWith(
        expect.objectContaining({
          alt: '',
          role: 'presentation',
          'aria-hidden': 'true'
        }),
        expect.any(Object)
      );
    });

    it('should handle loading state announcements', () => {
      render(<OptimizedImage {...mockProps} />);
      
      const loadingStatus = screen.getByTestId('loading-status');
      expect(loadingStatus).toHaveAttribute('aria-live', 'polite');
      expect(loadingStatus).toHaveTextContent(/loading/i);
    });

    it('should announce load errors to screen readers', async () => {
      render(<OptimizedImage {...mockProps} src="/non-existent.jpg" />);

      const image = screen.getByTestId('optimized-image');
      fireEvent.error(image);

      await waitFor(() => {
        const errorStatus = screen.getByTestId('error-status');
        expect(errorStatus).toHaveAttribute('aria-live', 'assertive');
        expect(errorStatus).toHaveTextContent(/failed to load/i);
      });
    });
  });
});
================================================================================
File: ./src/components/__tests__/ErrorBoundary.test.tsx
================================================================================

import { render, screen } from '@testing-library/react';
import ErrorBoundary from '../ErrorBoundary';

const ErrorComponent = () => {
  throw new Error('Test error');
};

// Suppress console.error for our test error
const originalError = console.error;
beforeAll(() => {
  console.error = jest.fn();
});

afterAll(() => {
  console.error = originalError;
});

describe('ErrorBoundary', () => {
  it('renders children when there is no error', () => {
    render(
      <ErrorBoundary>
        <div>Test content</div>
      </ErrorBoundary>
    );
    
    expect(screen.getByText('Test content')).toBeInTheDocument();
  });

  it('renders error message when there is an error', () => {
    render(
      <ErrorBoundary>
        <ErrorComponent />
      </ErrorBoundary>
    );
    
    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /refresh page/i })).toBeInTheDocument();
  });

  it('renders custom fallback when provided', () => {
    const fallback = <div>Custom error message</div>;
    
    render(
      <ErrorBoundary fallback={fallback}>
        <ErrorComponent />
      </ErrorBoundary>
    );
    
    expect(screen.getByText('Custom error message')).toBeInTheDocument();
  });
});
================================================================================
File: ./src/components/widgets/__tests__/ContactForm.test.tsx
================================================================================

// src/components/widgets/__tests__/ContactForm.test.tsx
import { render, screen, act, fireEvent } from '@testing-library/react';
import ContactForm from '../ContactForm';

class MockXMLHttpRequest {
  open = jest.fn();
  send = jest.fn();
  setRequestHeader = jest.fn();
  status = 200;
  onload: (() => void) | null = null; 
  onerror: (() => void) | null = null;
  upload = {
    onprogress: null
  };
}

declare global {
  interface Window {
    XMLHttpRequest: typeof MockXMLHttpRequest;
  }
}

beforeEach(() => {
  global.XMLHttpRequest = MockXMLHttpRequest as any;
  jest.useFakeTimers();
});

afterEach(() => {
  jest.useRealTimers();
  jest.clearAllMocks();
});

describe('ContactForm', () => {
  it('renders form fields', async () => {
    render(<ContactForm />);
    
    expect(screen.getByLabelText(/name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/subject/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/message/i)).toBeInTheDocument();
  }, 30000);

  it('handles form submission error', async () => {
    const mockXHR = new MockXMLHttpRequest();
    mockXHR.send.mockImplementation(function(this: any) {
      this.status = 500;
      this.onerror?.();
    });
    global.XMLHttpRequest = jest.fn(() => mockXHR) as any;

    render(<ContactForm />);
    const submitButton = screen.getByRole('button', { name: /send message/i });

    await act(async () => {
      fireEvent.click(submitButton);
      jest.runAllTimers();
    });

    expect(screen.getByText(/failed/i)).toBeInTheDocument();
  });
});
================================================================================
File: ./src/components/widgets/__tests__/CourseList.test.tsx
================================================================================

// src/components/widgets/__tests__/CourseList.test.tsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import CourseList from '../CourseList';
import { Course } from '@/types';

describe('CourseList Component', () => {
  const sampleCourses: Course[] = [
    {
      id: '1',
      title: 'Course 1',
      language: 'English',
      level: 'A1',
      schedule: 'Morning',
      imageUrl: 'http://example.com/image1.jpg',
      startDate: new Date().toISOString(),
      duration: '6 weeks',
      maxStudents: 20,
      price: 10000,
      description: 'Sample description 1'
    },
    {
      id: '2',
      title: 'Course 2',
      language: 'Spanish',
      level: 'B1',
      schedule: 'Afternoon',
      imageUrl: 'http://example.com/image2.jpg',
      startDate: new Date().toISOString(),
      duration: '8 weeks',
      maxStudents: 15,
      price: 12000,
      description: 'Sample description 2'
    },
  ];

  it('renders the course titles and images correctly', () => {
    render(<CourseList courses={sampleCourses} title="Test Courses" />);
    // Verify that the course titles are rendered
    expect(screen.getByText('Course 1')).toBeInTheDocument();
    expect(screen.getByText('Course 2')).toBeInTheDocument();
    // Verify that each course link is present
    sampleCourses.forEach(course => {
      expect(screen.getByRole('link', { name: new RegExp(course.title) })).toBeInTheDocument();
    });
  });

  it('renders a message when no courses are available', () => {
    render(<CourseList courses={[]} title="Test Courses" />);
    expect(screen.getByText('No courses available at this time.')).toBeInTheDocument();
  });
});

================================================================================
File: ./src/pages/courses/tests/[id].test.ts
================================================================================

// src/pages/api/courses/tests/[id].test.ts
jest.mock('next-auth', () => ({
  getServerSession: jest.fn(() => Promise.resolve({
    user: { email: process.env.ADMIN_EMAIL || 'admin@example.com' }
  }))
}));

// Rest of your test file remains the same
================================================================================
File: ./src/pages/api/courses/tests/[id].test.ts
================================================================================

/**
 * @fileoverview Tests for the courses API endpoint.
 *
 * These tests cover typical cases (successful GET, PUT, DELETE),
 * edge cases (missing course, invalid ID), and unauthorized access.
 */

import { createMocks } from 'node-mocks-http';
import handler from '../[id]';
import { NextApiRequest, NextApiResponse } from 'next';

// Mock next-auth's getServerSession to control authentication behavior.
jest.mock('next-auth', () => ({
  getServerSession: jest.fn(),
}));

import { getServerSession } from 'next-auth';

// Sample course data for testing.
const sampleCourse = {
  id: '1',
  title: 'Test Course',
  language: 'English',
  level: 'Beginner',
  schedule: 'Mondays',
  imageUrl: 'test-image.png',
  startDate: '2023-01-01',
  duration: '10 weeks',
  maxStudents: 20,
  price: 100,
  description: 'A test course description',
};

describe('Courses API Endpoint', () => {
  beforeEach(() => {
    // Reset global courses array before each test.
    globalThis.courses = [ { ...sampleCourse } ];
    jest.resetAllMocks();
  });

  test('GET: returns the course when a valid ID is provided', async () => {
    const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
      method: 'GET',
      query: { id: '1' },
    });

    await handler(req, res);
    expect(res._getStatusCode()).toBe(200);
    const data = JSON.parse(res._getData());
    expect(data.title).toBe('Test Course');
  });

  test('GET: returns 404 when course is not found', async () => {
    const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
      method: 'GET',
      query: { id: 'non-existent' },
    });

    await handler(req, res);
    expect(res._getStatusCode()).toBe(404);
    const data = JSON.parse(res._getData());
    expect(data.error).toBe('Course not found');
  });

  test('PUT: returns 401 when user is not authenticated', async () => {
    // Simulate getServerSession returning null (unauthenticated)
    (getServerSession as jest.Mock).mockResolvedValue(null);

    const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
      method: 'PUT',
      query: { id: '1' },
      body: { title: 'Updated Title', language: 'English', level: 'Intermediate' },
    });

    await handler(req, res);
    expect(res._getStatusCode()).toBe(401);
    const data = JSON.parse(res._getData());
    expect(data.error).toBe('Unauthorized');
  });

  test('PUT: returns 400 when required fields are missing', async () => {
    // Simulate an authenticated admin user.
    (getServerSession as jest.Mock).mockResolvedValue({
      user: { email: process.env.ADMIN_EMAIL || 'admin@example.com' },
    });

    const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
      method: 'PUT',
      query: { id: '1' },
      // Omitting required fields such as language and level.
      body: { title: 'Updated Title' },
    });

    await handler(req, res);
    expect(res._getStatusCode()).toBe(400);
    const data = JSON.parse(res._getData());
    expect(data.error).toBe('Missing required fields');
  });

  test('PUT: successfully updates a course when authenticated as admin', async () => {
    // Simulate an authenticated admin user.
    (getServerSession as jest.Mock).mockResolvedValue({
      user: { email: process.env.ADMIN_EMAIL || 'admin@example.com' },
    });

    const updatePayload = {
      title: 'Updated Course Title',
      language: 'English',
      level: 'Intermediate',
    };

    const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
      method: 'PUT',
      query: { id: '1' },
      body: updatePayload,
    });

    await handler(req, res);
    expect(res._getStatusCode()).toBe(200);
    const data = JSON.parse(res._getData());
    expect(data.title).toBe(updatePayload.title);
    expect(data.level).toBe(updatePayload.level);
  });

  test('DELETE: returns 401 when user is not authenticated', async () => {
    // Simulate unauthenticated access.
    (getServerSession as jest.Mock).mockResolvedValue(null);

    const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
      method: 'DELETE',
      query: { id: '1' },
    });

    await handler(req, res);
    expect(res._getStatusCode()).toBe(401);
    const data = JSON.parse(res._getData());
    expect(data.error).toBe('Unauthorized');
  });

  test('DELETE: successfully deletes a course when authenticated as admin', async () => {
    // Simulate an authenticated admin user.
    (getServerSession as jest.Mock).mockResolvedValue({
      user: { email: process.env.ADMIN_EMAIL || 'admin@example.com' },
    });

    const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
      method: 'DELETE',
      query: { id: '1' },
    });

    await handler(req, res);
    expect(res._getStatusCode()).toBe(204);
    // Verify that the course was removed from the global courses array.
    expect(globalThis.courses.length).toBe(0);
  });
});
